=head1 NAME

Catalyst::Manual::Tutorial::03_MoreCatalystBasics - Catalyst Tutorial - Chapter 3: More Catalyst Application Development Basics
Catalyst::Manual::Tutorial::03_MoreCatalystBasics - Catalyst 教學手冊 - Chapter 3: 更多 Catalyst 應用程式開發基礎

=head1 OVERVIEW

This is B<Chapter 3 of 10> for the Catalyst tutorial.

這是 B<Chapter 3 of 10> Catalyst 教學手冊。

L<Tutorial Overview|Catalyst::Manual::Tutorial>

=over 4

=item 1

L<Introduction|Catalyst::Manual::Tutorial::01_Intro>

=item 2

L<Catalyst Basics|Catalyst::Manual::Tutorial::02_CatalystBasics>

=item 3

B<03_More Catalyst Basics>

=item 4

L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>

=item 5

L<Authentication|Catalyst::Manual::Tutorial::05_Authentication>

=item 6

L<Authorization|Catalyst::Manual::Tutorial::06_Authorization>

=item 7

L<Debugging|Catalyst::Manual::Tutorial::07_Debugging>

=item 8

L<Testing|Catalyst::Manual::Tutorial::08_Testing>

=item 9

L<Advanced CRUD|Catalyst::Manual::Tutorial::09_AdvancedCRUD>

=item 10

L<Appendices|Catalyst::Manual::Tutorial::10_Appendices>

=back


=head1 DESCRIPTION

This chapter of the tutorial builds on the work done in Chapter 2 to
explore some features that are more typical of "real world" web
applications. From this chapter of the tutorial onward, we will be
building a simple book database application.  Although the application
will be too limited to be of use to anyone, it should provide a basic
environment where we can explore a variety of features used in virtually
all web applications.

教學手冊的本章節建立在先前完成的工作上，章節 2 時導覽一些典型 "真實世界" 的網頁應用程式。
教學手冊從本章開始之後，我們建置一個簡單的圖書資料庫應用程式。
雖然這個應用程式的使用對各位限制太多，它依然提供一些簡單的環境可以讓我們導覽假想的網頁應用程式各種該有的功能。

Source code for the tutorial in included in the F</home/catalyst/Final>
directory of the Tutorial Virtual machine (one subdirectory per
chapter).  There are also instructions for downloading the code in
L<Catalyst::Manual::Tutorial::01_Intro>.

教學手冊的原始碼包含在虛擬電腦映像檔的 F</home/catalyst/Final> 資料夾內 (字目錄分別為各章節)。
這裡也有說明如何下載範例映像檔 L<Catalyst::Manual::Tutorial::01_Intro>。

Please take a look at
L<Catalyst::Manual::Tutorial::01_Intro/STARTING WITH THE TUTORIAL VIRTUAL MACHINE>
before doing the rest of this tutorial.  Although the tutorial should
work correctly under most any recent version of Perl running on any
operating system, the tutorial has been written using the virtual
machine that is available for download.  The entire tutorial has been
tested to be sure it runs correctly in this environment, so it is
the most trouble-free way to get started with Catalyst.

請稍微在繼續接下來的教學前看一下 L<Catalyst::Manual::Tutorial::01_Intro/STARTING WITH THE TUTORIAL VIRTUAL MACHINE>。
雖然這個教學手冊的範例應該可以在您作業系統上最新的 Perl 版本正確運作，
這份教學手冊也提供了虛擬電腦映像檔提供下載。
所有的教學範例都已經在這個虛擬環境下測試並正確運行，所以 Catalyst 教學範例用虛擬環境啟動會比較少問題。

=head1 CREATE A NEW APPLICATION

=head1 建置一個新應用程式

The remainder of the tutorial will build an application called C<MyApp>.
First use the Catalyst F<catalyst.pl> script to initialize the framework
for the C<MyApp> application (make sure you aren't still inside the
directory of the C<Hello> application from the previous chapter of the
tutorial or in a directory that already has a "MyApp" subdirectory):

接下來的教學會建立一個應用程式命名為 C<MyApp>。
一開始請用 Catalyst F<catalyst.pl> 協助腳本來初始化 C<MyApp> 應用程式框架 
(請注意，請確認您的工作目錄不要還停留在前面章節的 C<Hello> 應用程式目錄，或是工作目錄下已經存在 "MyApp" 資料夾)：

    $ catalyst.pl MyApp
    created "MyApp"
    created "MyApp/script"
    created "MyApp/lib"
    created "MyApp/root"
    ...
    created "MyApp/script/myapp_create.pl"
    Change to application directory and Run "perl Makefile.PL" to make sure your install is complete

And change the "MyApp" directory the helper created:

然後進到協助腳本建立的 "MyApp" 資料夾：

    $ cd MyApp

This creates a similar skeletal structure to what we saw in Chapter 2 of
the tutorial, except with C<MyApp> and C<myapp> substituted for C<Hello>
and C<hello>.  (As noted in Chapter 2, omit the ".pl" from the command
if you are using Strawberry Perl.)

這樣就建置了和章節 2 教學手冊類似的骨架結構，除了 C<MyApp> 和 C<myapp> 取代了 C<Hello> 和 C<hello>。
(和章節 2 提到的一樣，如果您使用的是 Strawberry Perl 命令列請省略 ".pl"。)


=head1 EDIT THE LIST OF CATALYST PLUGINS

=head1 編輯 CATALYST 外掛列表

One of the greatest benefits of Catalyst is that it has such a large
library of base classes and plugins available that you can use to easily
add functionality to your application. Plugins are used to seamlessly
integrate existing Perl modules into the overall Catalyst framework. In
general, they do this by adding additional methods to the C<context>
object (generally written as C<$c>) that Catalyst passes to every
component throughout the framework.

Catalyst 最大的好處是擁有大量的基礎類別函式庫及外掛，任您很容易為您的應用程式增加功能。
外掛 (Plugin) 能夠和現有的 Perl 模組無縫整合進全面的 Catalyst 框架。
通常，增加額外的方法到 C<語境 (context)> 物件達到這個目的 (通常用 C<$c> 代表語境物件) 
Catalyst 並透過框架傳遞到每個元件。

Take a look at the file F<lib/MyApp.pm> that the helper created above.
By default, Catalyst enables three plugins/flags:

大概看一下前面協助腳本產生的 F<lib/MyApp.pm>。
預設，Catalyst 啟用 3 個外掛/旗標：

=over 4

=item *

C<-Debug> Flag

C<-Debug> 旗標

Enables the Catalyst debug output you saw when we started the
F<script/myapp_server.pl> development server earlier.  You can remove
this item when you place your application into production.

啟用 Catalyst 除錯輸出，先前我們運行 F<script/myapp_server.pl> 開發伺服器的時候。
產品發佈階段您可以把這個項目刪掉。

To be technically correct, it turns out that C<-Debug> is not a plugin,
but a I<flag>.  Although most of the items specified on the C<use
Catalyst> line of your application class will be plugins, Catalyst
supports a limited number of flag options (of these, C<-Debug> is the
most common).  See the documentation for
L<Catalyst.pm|Catalyst> to get details on
other flags (currently C<-Engine>, C<-Home>, C<-Log>, and C<-Stats>).

技術上來說，使用 C<-Debug> 實際上不是外掛而是 I<旗標 (falg)>。
雖然您的應用程式大多數 C<use Catalyst> 行上指定的項目為外掛，Catalyst 支援限制旗標選項的數量 (其中，C<-Debug> 最常見)。
請看說明文件 L<Catalyst.pm|Catalyst> 內詳細介紹旗標，其他的旗標詳細 (目前支援 C<-Engine>, C<-Home>, C<-Log>, 以及 C<-Stats>)。

If you prefer, there are several other ways to enable debug output:

根據您的喜好，有及種其他方式啟用除錯輸出：

=over 4

=item *

the C<< $c->debug >> method on the C<$c> Catalyst context object

C<< $c->debug >> 方法在 C<$c> Catalyst 語境物件 (context object)

=item *

the C<-d> option on the F<script/myapp_server.pl> script

F<script/myapp_server.pl> 協助腳本的命令列 C<-d> 選項

=item *

the C<CATALYST_DEBUG=1> environment variable (or C<CATALYST_DEBUG=0>
to temporarily disable debug output)

終端環境變數設為 C<CATALYST_DEBUG=1> (或 C<CATALYST_DEBUG=0> 暫時關閉除錯輸出)

=back

B<TIP>: Depending on your needs, it can be helpful to permanently remove
C<-Debug> from C<lib/MyApp.pm> and then use the C<-d> option to
F<script/myapp_server.pl> to re-enable it when needed.  We will not be
using that approach in the tutorial, but feel free to make use of it in
your own projects.

B<提示>： 根據您的需要，從 C<lib/MyApp.pm> 永久刪除 C<-Debug> 很有幫助，之後根據需要啟動 F<script/myapp_server.pl> 時再使用 C<-d> 選項啟用。
我們不會在教學手冊用這種引導方式，但是請放心自由的在您的專案裡使用。

=item *

L<Catalyst::Plugin::ConfigLoader>

C<ConfigLoader> provides an automatic way to load configurable
parameters for your application from a central
L<Config::General> file (versus having the values
hard-coded inside your Perl modules).  L<Config::General> uses syntax very
similar to Apache configuration files.  We will see how to use this
feature of Catalyst during the authentication and authorization sections
(L<Chapter 5|Catalyst::Manual::Tutorial::05_Authentication> and
L<Chapter 6|Catalyst::Manual::Tutorial::06_Authorization>).

C<ConfigLoader> 提供自動的方式從中央 (central) L<Config::General> 檔案載入設定參數 (相比在 Perl 模組裡硬編寫值)。
L<Config::General> 使用的語法和 Apache 設定檔非常相似。
我們會介紹如何使用這個 Catalyst 功能在認證和授權的章節。
(L<Chapter 5|Catalyst::Manual::Tutorial::05_Authentication> 及 L<Chapter 6|Catalyst::Manual::Tutorial::06_Authorization>)。

B<IMPORTANT NOTE:> If you are using a version of
L<Catalyst::Devel> prior to version 1.06, be aware that
Catalyst changed the default format from YAML to the more
straightforward L<Config::General> style.  This tutorial uses the newer
C<myapp.conf> file for L<Config::General>. However, Catalyst supports
both formats and will automatically use either F<myapp.conf> or
F<myapp.yml> (or any other format supported by
L<Catalyst::Plugin::ConfigLoader> and
L<Config::Any>).  If you are using a version of
L<Catalyst::Devel> prior to 1.06, you can convert to the newer format by
simply creating the F<myapp.conf> file manually and deleting
F<myapp.yml>.  The default contents of the F<myapp.conf> you create
should only consist of one line:

B<重要附註：> 如果您使用 L<Catalyst::Devel> 1.06 之前的版本，
請小心 Catalyst 已經把預設的 YAML 檔案格式改變成更直接的 L<Config::General> 風格。
本教學手冊使用新版更直接的 L<Config::General> 風格。
但是 Catalyst 支援這兩種格式並且自動讀取 F<myapp.conf> 或 F<myapp.yml> (或其他 L<Catalyst::Plugin::ConfigLoader> 和 L<Config::Any> 支援的類型)。
如果您使用 L<Catalyst::Devel> 1.06 之前的版本，您可以簡單地新增 F<myapp.conf> 檔案並且手動刪掉 F<myapp.yml>。
您新增的 F<myapp.conf> 檔案內容預設只有下面這一行：

    name MyApp

B<TIP>: This script can be useful for converting between configuration
formats:

B<TIP>: 下面這個命令列指令對轉換設定檔很有幫助：

    perl -Ilib -e 'use MyApp; use Config::General;
        Config::General->new->save_file("myapp.conf", MyApp->config);'

=item *

L<Catalyst::Plugin::Static::Simple>

C<Static::Simple> provides an easy way to serve static content, such as
images and CSS files, from the development server.

C<Static::Simple> 提供簡單的方法在開發伺服器發佈靜態內容，例如圖檔及 CSS 檔案。

=back

For our application, we want to add one new plugin to the mix.  To do
this, edit F<lib/MyApp.pm> (this file is generally referred to as your
I<application class>) and delete the lines with:

回到我們的教學應用程式，接著我們新增一組外掛。
要這麼做，編輯 F<lib/MyApp.pm> 增刪這一行：

    use Catalyst qw/
        -Debug
        ConfigLoader
        Static::Simple
    /;

Then replace it with:

修改成：

    # Load plugins
    use Catalyst qw/
        -Debug
        ConfigLoader
        Static::Simple

        StackTrace
    /;

B<Note:> Recent versions of L<Catalyst::Devel> have used a variety of
techniques to load these plugins/flags.  For example, you might see the
following:

B<請注意：> 最新版本的 L<Catalyst::Devel> 提供各式各樣的技巧載入這些外掛/旗標 (flags)。
舉例，您可能看過這一行：

    __PACKAGE__->setup(qw/-Debug ConfigLoader Static::Simple/);

Don't let these variations confuse you -- they all accomplish the same
result.

不要因這些變化感到困惑 -- 它們都是在完成同一件事。

This tells Catalyst to start using one additional plugin,
L<Catalyst::Plugin::StackTrace>, to add a stack trace near the top of
the standard Catalyst "debug screen" (the screen Catalyst sends to your
browser when an error occurs). Be aware that
L<StackTrace|Catalyst::Plugin::StackTrace> output appears in your
browser, not in the console window from which you're running your
application, which is where logging output usually goes.

這告訴 Catalyst 啟動時載入額外的外掛，L<Catalyst::Plugin::StackTrace>，
增加堆疊跟蹤 (stack trace) 在 Catalyst 標準 "除錯畫面" 
(當錯誤發生時 Catalyst 傳送到您的瀏覽器畫面，而不是您執行應用程式終端機的畫面，也是登入訊息輸出的地方)。

Make sure when adding new plugins you also include them as a new
dependency within the Makefile.PL file. For example, after adding the
StackTrace plugin the Makefile.PL should include the following line:

請確認當您新增外掛，您也必須包含它們進 Makefile.PL 檔案。
舉例來說，新增 StackTrace 外掛後 Makefile.PL 應該要包含下面一行：

    requires 'Catalyst::Plugin::StackTrace';


B<Notes:>

B<附註：>

=over 4

=item *

C<__PACKAGE__> is just a shorthand way of referencing the name of the
package where it is used.  Therefore, in F<MyApp.pm>, C<__PACKAGE__> is
equivalent to C<MyApp>.

C<__PACKAGE__> 只是參照到要使用套件的簡寫。
因此，在 F<MyApp.pm>，C<__PACKAGE__> 和 C<MyApp> 相同。

=item *

You will want to disable L<StackTrace|Catalyst::Plugin::StackTrace>
before you put your application into production, but it can be helpful
during development.

您應該要把 L<StackTrace|Catalyst::Plugin::StackTrace> 外掛關掉，在您將應用程式放在產品線上時，
但是開發期間很有幫助。

=item *

When specifying plugins, you can omit C<Catalyst::Plugin::> from the
name.  Additionally, you can spread the plugin names across multiple
lines as shown here or place them all on one line.

指定外掛時，您可以省略外掛名稱的 C<Catalyst::Plugin::>。
您可以分散多行外掛的名稱如下，也可以全部放在一行。

=item *

If you want to see what the StackTrace error screen looks like, edit
F<lib/MyApp/Controller/Root.pm> and put a C<die "Oops";> command in the
C<sub index :Path :Args(0)> method.  Then start the development server
and open C<http://localhost:3000/> in your browser.  You should get a
screen that starts with "Caught exception in
MyApp::Controller::Root->index" with sections showing a stacktrace,
information about the Request and Response objects, the stash (something
we will learn about soon), and the applications configuration.
B<Just don't forget to remove the die before you continue the tutorial!>
:-)

如果您想看看 StackTrace 錯誤訊息在螢幕上長什麼樣子，編輯 F<lib/MyApp/Controller/Root.pm> 
在 C<sub index :Path :Args(0)> 方法中加入 C<die "Oops";> 指令。
啟動開發伺服器並使用瀏覽器訪問 C<http://localhost:3000/>。
您會在螢幕上開頭看到 "Caught exception in MyApp::Controller::Root->index" 堆疊資訊部份，
以及請求及回應物件的資訊，以及應用程式設定檔。
B<繼續本教學之前別忘了把剛剛的 die 刪了！>:-)

=back


=head1 CREATE A CATALYST CONTROLLER

=head1 新增 Catalyst 控制器

As discussed earlier, controllers are where you write methods that
interact with user input.  Typically, controller methods respond to
C<GET> and C<POST> requests from the user's web browser.

先前討論過，控制器為瀏覽器使用者輸入與您編寫的方法之間的互動。
通常，控制器方法回應來自使用者瀏覽器 C<GET> 和 C<POST> 請求。

Use the Catalyst C<create> script to add a controller for book-related
actions:

使用 Catalyst C<create> 協助腳本新增一個控制器，有關書籍 C<Books> 的動作：

    $ script/myapp_create.pl controller Books
     exists "/home/catalyst/MyApp/script/../lib/MyApp/Controller"
     exists "/home/catalyst/MyApp/script/../t"
    created "/home/catalyst/MyApp/script/../lib/MyApp/Controller/Books.pm"
    created "/home/catalyst/MyApp/script/../t/controller_Books.t"

Then edit F<lib/MyApp/Controller/Books.pm> (as discussed in
L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics> of
the Tutorial, Catalyst has a separate directory under F<lib/MyApp> for
each of the three parts of MVC: C<Model>, C<View> and C<Controller>)
and add the following method to the controller:

接著編輯 F<lib/MyApp/Controller/Books.pm> 並且加入下面的控制器方法 (教學手冊 L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics> 討論過，
Catalyst 根據 MVC: C<模型>，C<視圖>和 C<控制器>，區分 F<lib/MyApp> 的子目錄)。

    =head2 list

    Fetch all book objects and pass to books/list.tt2 in stash to be displayed

    =cut

    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;

        # Retrieve all of the book records as book model objects and store in the
        # stash where they can be accessed by the TT template
        # $c->stash(books => [$c->model('DB::Book')->all]);
        # But, for now, use this code until we create the model later
        $c->stash(books => '');

        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (action methods respond to user input in
        # your controllers).
        $c->stash(template => 'books/list.tt2');
    }

B<TIP>: See L<Appendix 1|Catalyst::Manual::Tutorial::10_Appendices/APPENDIX 1: CUT AND PASTE FOR POD-BASED EXAMPLES>
for tips on removing the leading spaces when cutting and pasting example
code from POD-based documents.

B<提示>：請看 L<Appendix 1|Catalyst::Manual::Tutorial::10_Appendices/APPENDIX 1: CUT AND PASTE FOR POD-BASED EXAMPLES>
如何移除 POD 文件中的範例程式開頭的縮排。

Programmers experienced with object-oriented Perl should recognize
C<$self> as a reference to the object where this method was called.  On
the other hand, C<$c> will be new to many Perl programmers who have not
used Catalyst before.  This is the "Catalyst Context object", and it is
automatically passed as the second argument to all Catalyst action
methods.  It is used to pass information between components and provide
access to Catalyst and plugin functionality.

熟悉 Perl 物件導向的程式設計師應該理解 C<$self> 為呼叫這個方法的物件參照。
換句話說，而 C<$c> 對沒使用過 Catalyst 的人是陌生的。
這是 "Catalyst 語境物件 (Context Objext)"，它會自動作為第 2 個引數傳遞給任何 Catalyst 動作方法。
這個作用是傳遞元件資訊及提供存取 Catalyst 及外掛的能力。

Catalyst Controller actions are regular Perl methods, but they make use
of attributes (the "C<:Local>" next to the "C<sub list>" in the code
above) to provide additional information to the Catalyst dispatcher
logic (note that there can be an optional space between the colon and
the attribute name; you will see attributes written both ways).  Most
Catalyst Controllers use one of five action types:

Catalyst 控制器動作為常見的 Perl 方法，但是它們能利用B<屬性>提供額外的 Catalyst B<分派>邏輯
(例如上面例子 "C<sub list>" 接續的 "C<:Local>")。
(請注意冒號和屬性名稱旁邊的空白是可選的，您之後會看到這兩種方式)。
大部分的 Catalyst 控制器屬性使用 5 種動作類型：

=over 4

=item *"C<:Local>"

B<:Private> -- Use C<:Private> for methods that you want to make into an
action, but you do not want Catalyst to directly expose the method to
your users.  Catalyst will not map C<:Private> methods to a URI.  Use
them for various sorts of "special" methods (the C<begin>, C<auto>, etc.
discussed below) or for methods you want to be able to C<forward> or
C<detach> to.  (If the method is a "plain old method" that you
don't want to be an action at all, then just define the method without
any attribute -- you can call it in your code, but the Catalyst
dispatcher will ignore it.  You will also have to manually include
C<$c> if you want access to the context object in the method vs. having
Catalyst automatically include C<$c> in the argument list for you
if it's a full-fledged action.)

B<:Private> -- 當您想要建立一個動作方法，但是又不想直接暴露到您的使用者，請使用 C<:Private>。
Catalyst 不會讓 C<:Private> 方法映射到 URL。
("特殊" 方法時或 C<forward> 及 C<detach> 呼叫時才使用它們 (C<begin>, C<auto> 下面會討論)。
(如果方法是 "簡明老式方法" 您不想要它成為動作，只要定義時不包含任何參數 -- 
您可以在自己的程式中呼叫但是 Catalyst 分派功能會忽略它。同時您也必須手動包含進 C<$c> 如果您的方法須要使用語境物件。
自動把 C<$c> 包含進您動作方法的引數，它就是一個完整的動作。)


There are five types of "special" built-in C<:Private> actions:
C<begin>, C<end>, C<default>, C<index>, and C<auto>.

C<:Private> 修飾詞內部有 5 個內建 "特殊" 動作方法：
C<begin>, C<end>, C<default>, C<index>, 以及 C<auto>。

=over 4

=item *

With C<begin>, C<end>, C<default>, C<index> private actions, only the
most specific action of each type will be called.  For example, if you
define a C<begin> action in your controller it will I<override> a
C<begin> action in your application/root controller -- I<only> the
action in your controller will be called.

使用 C<begin>, C<end>, C<default>, C<index> 私有方法，
代表各自只有特殊的情況會被呼叫。例如，C<begin> 動作在您的控制器中定義後會I<覆寫>應用程式/控制器中的 C<begin> 動作 --
I<只有>定義在此的控制器中可以呼叫。

=item *

Unlike the other actions where only a single method is called for each
request, I<every> auto action along the chain of namespaces will be
called.  Each C<auto> action will be called I<from the application/root
controller down through the most specific class>.

不像其他動作一次請求只會呼叫一次動作方法，C<auto> 動作會在I<每一個>會在每一個名稱空間鏈接時呼叫。
從I<應用程式/root 控制器向下到最下層的類別>中的每一個 C<auto> 都會被呼叫。

=back

=item *

B<:Path> -- C<:Path> actions let you map a method to an explicit URI
path.  For example, "C<:Path('list')>" in
F<lib/MyApp/Controller/Books.pm> would match on the URL
C<http://localhost:3000/books/list>, but "C<:Path('/list')>" would match
on C<http://localhost:3000/list> (because of the leading slash).  You
can use C<:Args()> to specify how many arguments an action should
accept.  See L<Catalyst::Manual::Intro/Action-types> for more
information and examples.

B<:Path> -- C<:Path> 動作映射到明確的 URL 路徑。
例如， "C<:Path('list')>" 時在 F<lib/MyApp/Controller/Books.pm> 中代表 URL 會匹配 C<http://localhost:3000/books/list>，
但是 "C<:Path('/list')>" 會匹配 C<http://localhost:3000/list> (被開頭的斜線影響)。
您可以使用 C<:Args()> 來指定路徑引數的數量多寡。
請看 L<Catalyst::Manual::Intro/Action-types> 來獲得更多資訊。

=item *

B<:Local> -- C<:Local> is merely a shorthand for
"C<:Path('_name_of_method_')>".  For example, these are equivalent:
"C<sub create_book :Local {...}>" and
"C<sub create_book :Path('create_book') {...}>".

B<:Local> -- C<:Local> 僅僅是 "C<:Path('_name_of_method_')>" 的簡寫。
舉例來說，這兩個同等：
"C<sub create_book :Local {...}>" 相同於 "C<sub create_book :Path('create_book') {...}>"。

=item *

B<:Global> -- C<:Global> is merely a shorthand for
"C<:Path('/_name_of_method_')>".  For example, these are equivalent:
"C<sub create_book :Global {...}>" and "C<sub create_book
:Path('/create_book') {...}>".

B<:Global> -- C<:Global> 僅僅等同於 "C<:Path('/_name_of_method_')>"。
舉例來說這兩個同等：
"C<sub create_book :Global {...}>" 和 "C<sub create_book :Path('/create_book') {...}>"。

=item *

B<:Chained> -- Newer Catalyst applications tend to use the Chained
dispatch form of action types because of its power and flexibility.  It
allows a series of controller methods to be automatically dispatched
when servicing a single user request.  See
L<Catalyst::Manual::Tutorial::04_BasicCRUD> and
L<Catalyst::DispatchType::Chained> for more information on chained
actions.

B<:Chained> -- 較新的 Catalyst 偏好使用鏈式分派的動作類型，因為其強大的彈性。
單個使用者請求時，它允許自動分派一系列的控制器方法。請看 L<Catalyst::Manual::Tutorial::04_BasicCRUD> 及 L<Catalyst::DispatchType::Chained> 獲得更多有關鏈接的資訊。

=back

You should refer to L<Catalyst::Manual::Intro/Action-types> for
additional information and for coverage of some lesser-used action types
not discussed here (C<Regex> and C<LocalRegex>).

您應該參考 L<Catalyst::Manual::Intro/Action-types> 獲得進一步資訊，
這邊沒討論到較少用到的功能 (C<Regex> 及 C<LocalRegex>)。


=head1 CATALYST VIEWS

As mentioned in L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics>
of the tutorial, views are where you render output, typically for
display in the user's web browser (but can generate other types of
output such as PDF or JSON).  The code in F<lib/MyApp/View> selects the
I<type> of view to use, with the actual rendering template found in the
C<root> directory.  As with virtually every aspect of Catalyst, options
abound when it comes to the specific view technology you adopt inside
your application. However, most Catalyst applications use the Template
Toolkit, known as TT (for more information on TT, see
L<http://www.template-toolkit.org>). Other somewhat popular view
technologies include Mason (L<http://www.masonhq.com> and
L<https://masonbook.houseabsolute.com/book/>) and L<HTML::Template>.

先前教學手冊提到 L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics>，
視圖為您呈現 (render) 的輸出，通常是使用者的網頁瀏覽器 (但是也可以輸出為其他類型如 PDF 或 JSON)。
F<lib/MyApp/View> 內的程式選擇要使用的視圖I<類型>，真正要被呈現的模板則放在 C<root> 資料夾。
和所有 Catalyst 各方面相同，要在您應用程式採用哪些視圖的技術，都提供了各種選項。
但是，大部分的 Catalyst 應用程式使用了模板工具 (Template Toolkit)，就是 TT (有關 TT 的資訊請看 L<http://www.template-toolkit.org>)。
其他熱門的技術包括 Mason (L<http://www.masonhq.com> 及 L<https://masonbook.houseabsolute.com/book/>) 及 L<HTML::Template>.


=head2 Create a Catalyst View

=head2 新增 Catalyst 視圖

When using TT for the Catalyst view, the main helper script is
L<Catalyst::Helper::View::TT>.  You may also come across references to
L<Catalyst::Helper::View::TTSite>, but its use is now deprecated.

當您要使用 TT 作為 Catalyst 視圖工具時，主要的協助腳本為 L<Catalyst::Helper::View::TT>。
您也會遇到 L<Catalyst::Helper::View::TTSite>，但是已經棄用。

For our book application, enter the following command to enable the
C<TT> style of view rendering:

對於我們的書籍應用程式，下面的指令可以建置一個 C<TT> 風格的視圖呈現元件：

    $ script/myapp_create.pl view HTML TT
     exists "/home/catalyst/MyApp/script/../lib/MyApp/View"
     exists "/home/catalyst/MyApp/script/../t"
     created "/home/catalyst/MyApp/script/../lib/MyApp/View/HTML.pm"
     created "/home/catalyst/MyApp/script/../t/view_HTML.t"

This creates a view called C<HTML> (the first argument) in a file called
C<HTML.pm> that uses L<Catalyst::View::TT> (the second argument) as the
"rendering engine".

上例我們建置了名稱為 C<HTML> 的視圖元件 (指令地一個引數) 並使用 L<Catalyst::View::TT> 做為 "呈現引擎"。

It is now up to you to decide how you want to structure your view
layout.  For the tutorial, we will start with a very simple TT template
to initially demonstrate the concepts, but quickly migrate to a more
typical "wrapper page" type of configuration (where the "wrapper"
controls the overall "look and feel" of your site from a single file or
set of files).

現在要如何架構您的視圖則根據您的決定了。
本教學手冊，我們會從一個非常簡單的 TT 模板開始來展示初步的概念，
但是也會快速的整合更多典型的 "包裹網頁" 設定類型 ("包裹" 包含您網站的單個或數個檔案，控制全面的 "外觀和感覺")。

Edit F<lib/MyApp/View/HTML.pm> and you should see something similar to
the following:

編輯 F<lib/MyApp/View/HTML.pm> 您應該會看到類似如下：

    __PACKAGE__->config(
        TEMPLATE_EXTENSION => '.tt',
        render_die => 1,
    );

And update it to match:

然後更新成匹配：

    __PACKAGE__->config(
        # Change default TT extension
        TEMPLATE_EXTENSION => '.tt2',
        render_die => 1,
    );

This changes the default extension for Template Toolkit from '.tt' to
'.tt2'.

改變成預設的模板工具檔案從 '.tt' 為 '.tt2'。

You can also configure components in your application class. For
example, Edit F<lib/MyApp.pm> and you should see the default
configuration above the call to C<< _PACKAGE__->setup >> (your defaults
could be different depending on the version of Catalyst you are using):

您也可以在您的應用程式類別中設定使用的模組。
例如，編輯 F<lib/MyApp.pm> 然後您應該會看到如上預設的 C<< _PACKAGE__->setup >> 設定 
(您的預設設定可能會因為 Catalyst 版本不同而有差異)：

    __PACKAGE__->config(
        name => 'MyApp',
        # Disable deprecated behavior needed by old applications
        disable_component_resolution_regex_fallback => 1,
    );


Change this to match the following (insert a new
C<< __PACKAGE__->config >> below the existing statement):

改變這些來匹配 (原有的述句下方插入新的 C<< __PACKAGE__->config >>)：

    __PACKAGE__->config(
        name => 'MyApp',
        # Disable deprecated behavior needed by old applications
        disable_component_resolution_regex_fallback => 1,
    );
    __PACKAGE__->config(
        # Configure the view
        'View::HTML' => {
            #Set the location for TT files
            INCLUDE_PATH => [
                __PACKAGE__->path_to( 'root', 'src' ),
            ],
        },
    );

This changes the base directory for your template files from C<root> to
F<root/src>.

這樣將您的模板檔案從 C<root> 改成 F<root/src>。

Please stick with the settings above for the duration of the tutorial,
but feel free to use whatever options you desire in your applications
(as with most things in Perl, there's more than one way to do it...).

請持續使用上面的設定 (path_to) 於後續的教學期間，但是您還是可以自由的更改您應用程式的選項
(Perl 最重要的價值，一件事可以用各種方法完成它...)。

B<Note:> We will use F<root/src> as the base directory for our template
files, with a full naming convention of
F<root/src/_controller_name_/_action_name_.tt2>.  Another popular option
is to use F<root/> as the base (with a full filename pattern of
F<root/_controller_name_/_action_name_.tt2>).

B<請注意：>我們使用 F<root/src> 作為模板檔案的基礎資料夾位置，模板檔案的完整路定有個慣例 
F<root/src/_controller_name_/_action_name_.tt2>。
另外一個常用的選項 F<root/> 作為基礎資料夾路徑 (完整路徑樣式則為 F<root/_controller_name_/_action_name_.tt2>)。

=head2 Create a TT Template Page

=head2 建立一個 TT 模板網頁

First create a directory for book-related TT templates:

首先新增一個書籍網頁用的 TT 模板資料夾：

    $ mkdir -p root/src/books

Then create F<root/src/books/list.tt2> in your editor and enter:

然後新建一個檔案 F<root/src/books/list.tt2> 並且用編輯器輸入：

    [% # This is a TT comment. -%]

    [%- # Provide a title -%]
    [% META title = 'Book List' -%]

    [% # Note That the '-' at the beginning or end of TT code  -%]
    [% # "chomps" the whitespace/newline at that end of the    -%]
    [% # output (use View Source in browser to see the effect) -%]

    [% # Some basic HTML with a loop to display books -%]
    <table>
    <tr><th>Title</th><th>Rating</th><th>Author(s)</th></tr>
    [% # Display each book in a table row %]
    [% FOREACH book IN books -%]
      <tr>
        <td>[% book.title %]</td>
        <td>[% book.rating %]</td>
        <td></td>
      </tr>
    [% END -%]
    </table>

As indicated by the inline comments above, the C<META title> line uses
TT's META feature to provide a title to the "wrapper" that we will
create later (and essentially does nothing at the moment). Meanwhile,
the C<FOREACH> loop iterates through each C<book> model object and
prints the C<title> and C<rating> fields.

上面內聯 (inline) 的註解中表明，C<META title> 內聯行使用 TT 的 META 功能提供 "包裹" 
接下來會建立的變數 (實際上這個時間點沒做什麼) 同時，
C<FOREACH> 迴圈迭代 C<book> 模型 (model) 物件並且印出 C<title> 及 C<rating> 欄位。

The C<[%> and C<%]> tags are used to delimit Template Toolkit code.  TT
supports a wide variety of directives for "calling" other files,
looping, conditional logic, etc.  In general, TT simplifies the usual
range of Perl operators down to the single dot (".") operator.  This
applies to operations as diverse as method calls, hash lookups, and list
index values (see L<Template::Manual::Variables> for details and
examples).  In addition to the usual L<Template::Toolkit> module Pod
documentation, you can access the TT manual at
L<Template::Manual>.

C<[%> 和 C<%]> 標籤被用在區分模板工具程式碼。
TT 支援非常廣泛的指令，如 "呼叫" 其他檔案，迴圈，條件邏輯，其他。
一般來說，TT 簡化了 Perl 運算符的範圍到只用點號 "." 運算符。
這種運算符變化依然和函式呼叫，雜湊查詢，以及列表定位 (請看 L<Template::Manual::Variables> 獲得詳細範例)。
更多常用的 L<Template::Toolkit> POD 說明文件，您可以直接查閱 TT 說明文件 L<Template::Manual>。

B<TIP:> While you can build all sorts of complex logic into your TT
templates, you should in general keep the "code" part of your templates
as simple as possible.  If you need more complex logic, create helper
methods in your model that abstract out a set of code into a single call
from your TT template.  (Note that the same is true of your controller
logic as well -- complex sections of code in your controllers should
often be pulled out and placed into your model objects.)  In
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD> of the tutorial we
will explore some extremely helpful and powerful features of
L<DBIx::Class> that allow you to pull code out of your views and
controllers and place it where it rightfully belongs in a model class.

B<提示：>當您建立稍微複雜的 TT 模板邏輯時，您通常應該把 "原始碼" 盡可能的跟模板檔案區分來簡化複雜性。
如果您需要比較複雜的邏輯，新增您的協助B<模板>元件抽象化您的程式碼，讓您的 TT 模板能夠以單一呼叫使用。
(請注意，和您的控制器邏輯一樣，控制器元件程式碼複雜的部份您應該放在外部，放在您的模型物件中。)
教學手冊 L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD> 會導覽一些強大有幫助的 L<DBIx::Class> 功能，
讓您把部份程式碼放在視圖及控制器元件之外，並且根據模型類別適當存取。


=head2 Test Run The Application

=head2 測試運行應用程式

To test your work so far, first start the development server:

測試到目前為止的工作，啟動您的開發伺服器：

    $ script/myapp_server.pl -r

Then point your browser to L<http://localhost:3000> and you should still
get the Catalyst welcome page.  Next, change the URL in your browser to
L<http://localhost:3000/books/list>.  If you have everything working so
far, you should see a web page that displays nothing other than our
column headers for "Title", "Rating", and "Author(s)" -- we will not see
any books until we get the database and model working below.

回到您的網頁瀏覽器 L<http://localhost:3000> 而您還是會看到 Catalyst 歡迎畫面。
改變您的 URL 到 L<http://localhost:3000/books/list>。
如果先前的設定順利，您應該會看到畫面什麼沒有就只有我們欄位的標頭 "Title"，"Rating"，以及 "Author(s)" -- 
直到訪問資料庫且模型元件運作前我們看不到書籍資料。

If you run into problems getting your application to run correctly, it
might be helpful to refer to some of the debugging techniques covered in
the L<Debugging|Catalyst::Manual::Tutorial::07_Debugging> chapter of the
tutorial.

如果您在運行應用程式時遇到問題，一些除錯的技巧對您會有幫助，請參考教學手冊章節 L<Debugging|Catalyst::Manual::Tutorial::07_Debugging>。

=head1 CREATE A SQLITE DATABASE

=head1 新增 SQLITE 資料庫

In this step, we make a text file with the required SQL commands to
create a database table and load some sample data.  We will use SQLite
(L<https://www.sqlite.org>), a popular database that is lightweight and
easy to use. Be sure to get at least version 3. Open F<myapp01.sql> in
your editor and enter:

這一步，我們建立 SQL 請求的文字檔來建立資料庫及資料表，並且載入一些範例資料。
我們使用 SQLite (L<https://www.sqlite.org>)，輕巧熱門有容易使用的資料庫系統。
請注意下載版本 3。編輯器打開 F<myapp01.sql> 輸入：

    --
    -- Create a very simple database to hold book and author information
    --
    PRAGMA foreign_keys = ON;
    CREATE TABLE book (
            id          INTEGER PRIMARY KEY,
            title       TEXT ,
            rating      INTEGER
    );
    -- 'book_author' is a many-to-many join table between books & authors
    CREATE TABLE book_author (
            book_id     INTEGER REFERENCES book(id) ON DELETE CASCADE ON UPDATE CASCADE,
            author_id   INTEGER REFERENCES author(id) ON DELETE CASCADE ON UPDATE CASCADE,
            PRIMARY KEY (book_id, author_id)
    );
    CREATE TABLE author (
            id          INTEGER PRIMARY KEY,
            first_name  TEXT,
            last_name   TEXT
    );
    ---
    --- Load some sample data
    ---
    INSERT INTO book VALUES (1, 'CCSP SNRS Exam Certification Guide', 5);
    INSERT INTO book VALUES (2, 'TCP/IP Illustrated, Volume 1', 5);
    INSERT INTO book VALUES (3, 'Internetworking with TCP/IP Vol.1', 4);
    INSERT INTO book VALUES (4, 'Perl Cookbook', 5);
    INSERT INTO book VALUES (5, 'Designing with Web Standards', 5);
    INSERT INTO author VALUES (1, 'Greg', 'Bastien');
    INSERT INTO author VALUES (2, 'Sara', 'Nasseh');
    INSERT INTO author VALUES (3, 'Christian', 'Degu');
    INSERT INTO author VALUES (4, 'Richard', 'Stevens');
    INSERT INTO author VALUES (5, 'Douglas', 'Comer');
    INSERT INTO author VALUES (6, 'Tom', 'Christiansen');
    INSERT INTO author VALUES (7, 'Nathan', 'Torkington');
    INSERT INTO author VALUES (8, 'Jeffrey', 'Zeldman');
    INSERT INTO book_author VALUES (1, 1);
    INSERT INTO book_author VALUES (1, 2);
    INSERT INTO book_author VALUES (1, 3);
    INSERT INTO book_author VALUES (2, 4);
    INSERT INTO book_author VALUES (3, 5);
    INSERT INTO book_author VALUES (4, 6);
    INSERT INTO book_author VALUES (4, 7);
    INSERT INTO book_author VALUES (5, 8);

Then use the following command to build a F<myapp.db> SQLite database:

命令列使用下面指令建置 F<myapp.db> SQLite 資料庫：

    $ sqlite3 myapp.db < myapp01.sql

If you need to create the database more than once, you probably want to
issue the C<rm myapp.db> command to delete the database before you use
the C<< sqlite3 myapp.db < myapp01.sql >> command.

如果您多次建立資料庫時，您應該要 C<rm myapp.db> 刪除先前建立過的 SQLite 資料庫檔案。
才使用 C<< sqlite3 myapp.db < myapp01.sql >> 指令。

Once the F<myapp.db> database file has been created and initialized, you
can use the SQLite command line environment to do a quick dump of the
database contents:

自從您建立並初始化 F<myapp.db> 資料庫後，您可以使用 SQLite 指令環境快速傾印資料庫內容：

    $ sqlite3 myapp.db
    SQLite version 3.7.3
    Enter ".help" for instructions
    Enter SQL statements terminated with a ";"
    sqlite> select * from book;
    1|CCSP SNRS Exam Certification Guide|5
    2|TCP/IP Illustrated, Volume 1|5
    3|Internetworking with TCP/IP Vol.1|4
    4|Perl Cookbook|5
    5|Designing with Web Standards|5
    sqlite> .q
    $

Or:

或：

    $ sqlite3 myapp.db "select * from book"
    1|CCSP SNRS Exam Certification Guide|5
    2|TCP/IP Illustrated, Volume 1|5
    3|Internetworking with TCP/IP Vol.1|4
    4|Perl Cookbook|5
    5|Designing with Web Standards|5

As with most other SQL tools, if you are using the full "interactive"
environment you need to terminate your SQL commands with a ";" (it's not
required if you do a single SQL statement on the command line).  Use
".q" to exit from SQLite from the SQLite interactive mode and return to
your OS command prompt.

像是大部分的 SQL 工具，如果您使用全 "互動" 環境您在指令尾端應加上中止符分號 ";" 
(如果是命令列單行 SQL 述句 則可以不需要)。
互動環境模式中使用 ".q" 離開並返回您作業系統的命令列。

Please note that here we have chosen to use 'singular' table names. This
is because the default inflection code for older versions of
L<DBIx::Class::Schema::Loader> does NOT handle plurals. There has been
much philosophical discussion on whether table names should be plural or
singular.  There is no one correct answer, as long as one makes a choice
and remains consistent with it. If you prefer plural table names (e.g.
you think that they are easier to read) then see the documentation in
L<DBIx::Class::Schema::Loader::Base/naming> (version 0.05 or greater).

請注意我們採用 '單數' 資料表名稱。因為舊版本的 L<DBIx::Class::Schema::Loader> 不能處理複數名稱。
網路上有很多討論命名單數或複數的哲學，沒有正確的答案，只有您選擇堅持哪個，如果您偏好複數名稱 
(例如您覺得比較容易閱讀) 請看說明文件 L<DBIx::Class::Schema::Loader::Base/naming> (版本 0.05 或之後)。

For using other databases, such as PostgreSQL or MySQL, see
L<Appendix 2|Catalyst::Manual::Tutorial::10_Appendices/APPENDIX 2: USING POSTGRESQL AND MYSQL>.

關於使用其他資料庫，如 PostgreSQL 或 MySQL，請看 L<Appendix 2|Catalyst::Manual::Tutorial::10_Appendices/APPENDIX 2: USING POSTGRESQL AND MYSQL>。


=head1 DATABASE ACCESS WITH DBIx::Class

=head1 使用 DBIx::Class 存取資料庫

Catalyst can be used with virtually any form of datastore available via
Perl.  For example, L<Catalyst::Model::DBI> can be used to access
databases through the traditional Perl L<DBI> interface or you can use a
model to access files of any type on the filesystem.  However, most
Catalyst applications use some form of object-relational mapping (ORM)
technology to create objects associated with tables in a relational
database, and Matt Trout's L<DBIx::Class> (abbreviated as "DBIC") is the
usual choice (this tutorial will use L<DBIx::Class>).

Catalyst 幾乎可以使用所有 Perl 可用的 Database 類別。
例如，L<Catalyst::Model::DBI> 可以透過傳統的 Perl L<DBI> 界面存取，或者您可以使用模型元件存取各種類型的檔案系統。
然而，大部分的 Catalyst 應用程式使用關聯式資料庫，建立物件關聯映射 (object-relational mapping ORM) 技術與資料表建立關聯，
而通常會採用 Matt Trout 的 L<DBIx::Class> (縮寫 "DBIC") (本教學手冊使用 L<DBIx::Class>)。

Although DBIx::Class has included support for a C<create=dynamic> mode
to automatically read the database structure every time the application
starts, its use is no longer recommended.  While it can make for
"flashy" demos, the use of the C<create=static> mode we use below can be
implemented just as quickly and provides many advantages (such as the
ability to add your own methods to the overall DBIC framework, a
technique that we see in
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD>).

雖然 DBIx::Class 內建支援設定 C<create=dynamic> 模式在應用程式運行時讀取資料庫，
但是不再建議您使用這種作法。
而您 "初步的" DEMO 裡，下面例子 C<create=static> 的設定可以實現速度及許多好處 
(例如可以在 DBIC 框架之下使用您自己的方法，這個技巧請看 L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD>)。

=head2 Create Static DBIx::Class Schema Files

=head2 建立靜態的 DBIx::Class Schema 檔案

B<Note:> If you are not following along in the Tutorial Virtual Machine,
please be sure that you have version 1.27 or higher of L<DBD::SQLite> and
version 0.39 or higher of L<Catalyst::Model::DBIC::Schema>.  (The Tutorial
VM already has versions that are known to work.)  You can get your
currently installed version numbers with the following commands.

B<請注意：>如果您不是使用教學虛擬電腦映像檔，請確認您的 L<DBD::SQLite> 版本在 1.27 或更新並且 L<Catalyst::Model::DBIC::Schema> 版本 0.39 或更新。
(教學映像檔的版本正確並且已知能順利運作。)
您可以查看您的套件版本使用命令列指令如下。

    $ perl -MCatalyst::Model::DBIC::Schema\ 999
    $ perl -MDBD::SQLite\ 999

Before you continue, make sure your F<myapp.db> database file is in the
application's topmost directory. Now use the model helper with the
C<create=static> option to read the database with
L<DBIx::Class::Schema::Loader> and
automatically build the required files for us:

繼續以前，確認您的 F<myapp.db> 資料庫檔案置於應用程式的頂層目錄。
現在使用協助腳本設定套件 L<DBIx::Class::Schema::Loader> 讀取選項 C<create=static> 並且自動建置我們需要的檔案：

    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \
        create=static dbi:SQLite:myapp.db \
        on_connect_do="PRAGMA foreign_keys = ON"
     exists "/home/catalyst/MyApp/script/../lib/MyApp/Model"
     exists "/home/catalyst/MyApp/script/../t"
    Dumping manual schema for MyApp::Schema to directory /home/catalyst/MyApp/script/../lib ...
    Schema dump completed.
    created "/home/catalyst/MyApp/script/../lib/MyApp/Model/DB.pm"
    created "/home/catalyst/MyApp/script/../t/model_DB.t"

Please note the '\' above.  Depending on your environment, you might be
able to cut and paste the text as shown or need to remove the '\'
character to that the command is all on a single line.

請注意 "\" 反斜線 (換行)，取決於您的命令列環境，您也可以把 '\' 刪掉才複製貼上，這樣命令列就是整整一行。

The F<script/myapp_create.pl> command breaks down like this:

F<script/myapp_create.pl> 指令分解說明如下：

=over 4

=item *

C<DB> is the name of the model class to be created by the helper in
the F<lib/MyApp/Model> directory.

C<DB> 為模型元件的類別名稱，建立於 F<lib/MyApp/Model> 目錄。

=item *

C<DBIC::Schema> is the type of the model to create.  This equates to
L<Catalyst::Model::DBIC::Schema>, the standard way to use a DBIC-based
model inside of Catalyst.

C<DBIC::Schema> 為建立模型元件的類型，同等於 L<Catalyst::Model::DBIC::Schema>，
在 Catalyst 中使用 DBIC-基礎的標準方法。

=item *

C<MyApp::Schema> is the name of the DBIC schema file written to
F<lib/MyApp/Schema.pm>.

C<MyApp::Schema> 為 DBIC 設計 (schema) 檔案，寫進 F<lib/MyApp/Schema.pm>。

=item *

C<create=static> causes L<DBIx::Class::Schema::Loader> to load the
schema as it runs and then write that information out into
F<lib/MyApp/Schema.pm> and files under the F<lib/MyApp/Schema>
directory.

C<create=static> 選項告訴 L<DBIx::Class::Schema::Loader> 運行時載入設計綱要，
並且將資訊寫入 F<lib/MyApp/Schema.pm> 以及 F<lib/MyApp/Schema> 目錄下的檔案。

=item *

C<dbi:SQLite:myapp.db> is the standard DBI connect string for use with
SQLite.

C<dbi:SQLite:myapp.db> 為 SQLite 標準的 DBI 連線。

=item *

And finally, the C<on_connect_do> string requests that
L<DBIx::Class::Schema::Loader> create
foreign key relationships for us (this is not needed for databases such
as PostgreSQL and MySQL, but is required for SQLite). If you take a look
at F<lib/MyApp/Model/DB.pm>, you will see that the SQLite pragma is
propagated to the Model, so that SQLite's recent (and optional) foreign
key enforcement is enabled at the start of every database connection.

最後，C<on_connect_do> 請求 L<DBIx::Class::Schema::Loader> 替我們新增外來鍵 (foreign key) 關聯
(對有些資料庫如 PostgreSQL 和 MySQL 來說不需要，但是對 SQLite 需要)。
如果您查看 F<lib/MyApp/Model/DB.pm>，您會看到 SQLite 指示詞 (pragma) 已經傳遞至模型元件，
所以 SQLite 最近 (可選的) 的外來鍵在每次資料庫連線時強制啟用。

=back


If you look in the F<lib/MyApp/Schema.pm> file, you will find that it
only contains a call to the C<load_namespaces> method.  You will also
find that F<lib/MyApp> contains a C<Schema> subdirectory, which then has
a subdirectory called "Result".  This "Result" subdirectory then has
files named according to each of the tables in our simple database
(F<Author.pm>, F<BookAuthor.pm>, and F<Book.pm>).  These three files are
called "Result Classes" (or
"L<ResultSource Classes|DBIx::Class::ResultSource>") in DBIx::Class
nomenclature. Although the Result Class files are named after tables in
our database, the classes correspond to the I<row-level data> that is
returned by DBIC (more on this later, especially in
L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>).

如果您查看 F<lib/MyApp/Schema.pm> 檔案，您會發現只有一個稱為 C<load_namespaces> 的方法。
您也會發現 F<lib/MyApp> 包含 C<Schema> 子目錄，子目錄下包含 "Result" 目錄。
"Result" 子目錄根據我們的資料表每個欄位各有一個檔案 (F<Author.pm>, F<BookAuthor.pm>, 及 F<Book.pm>)。
這些檔案在 DBIx::Class 有個術語稱為 "結果類別 (Result Classes)" (或"L<ResultSource Classes|DBIx::Class::ResultSource>")。
雖然結果類別檔案根據我們的資料表命名，這些類別反映到I<列階層資料 (row-level data)>並由 DBIC 返回
(之後會有更多這方面的資訊特別是在 L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>) 。

The idea with the Result Source files created under
F<lib/MyApp/Schema/Result> by the C<create=static> option is to only
edit the files below the C<# DO NOT MODIFY THIS OR ANYTHING ABOVE!>
warning. If you place all of your changes below that point in the file,
you can regenerate the automatically created information at the top of
each file should your database structure get updated.

設定 C<create=static> 這個把B<結果檔案>新增在 F<lib/MyApp/Schema/Result> 的概念，
您只能編輯這個檔案 C<# DO NOT MODIFY THIS OR ANYTHING ABOVE!> 警告文之後的內容。
如果您在警告文後放置您所有的修改內容，會自動生成新建的資訊在每一個檔案的開頭，您的資料庫應該也會更新。


Also note the "flow" of the model information across the various files
and directories.  Catalyst will initially load the model from
F<lib/MyApp/Model/DB.pm>.  This file contains a reference to
F<lib/MyApp/Schema.pm>, so that file is loaded next.  Finally, the call
to C<load_namespaces> in C<Schema.pm> will load each of the "Result
Class" files from the F<lib/MyApp/Schema/Result> subdirectory.  The
final outcome is that Catalyst will dynamically create three
table-specific Catalyst models every time the application starts (you
can see these three model files listed in the debug output generated
when you launch the application).

也請注意資訊由每個目錄及檔案傳遞至模型元件的 "流程 (flow)"。
Catalyst 初始會載入 F<lib/MyApp/Model/DB.pm>。
這個檔案包含指向 F<lib/MyApp/Schema.pm> 的參照，所以接著載入這個。
最後，呼叫 C<Schema.pm> 中的 C<load_namespaces> 方法會讀進每個在 F<lib/MyApp/Schema/Result> 子目錄下的每個 "結果類別 (Result Class)" 檔案。
最後的輸出為，每次應用程式啟動時 Catalyst 動態的新增 3 個 Catalyst 資料表相關的模型
(啟動應用程式時您會看到這 3 個模型檔案列在命令列除錯輸出裡)。

Additionally, the F<lib/MyApp/Schema.pm> model can easily be loaded
outside of Catalyst, for example, in command-line utilities and/or cron
jobs. F<lib/MyApp/Model/DB.pm> provides a very thin "bridge" between
Catalyst and this external database model.  Once you see how we can
add some powerful features to our DBIC model in
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD>, the elegance
of this approach will start to become more obvious.

此外， F<lib/MyApp/Schema.pm> 模型可以很容易的載入外部 Catalyst，舉例來說，
在命令列工具中 and/or 排程工作 (cron jobs)。
F<lib/MyApp/Model/DB.pm> 提供 Catalyst 和外部資料庫模型輕薄的 "橋接 (bridge)"。
只要您看過我們 DBIC 模型 L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD> 強大的功能後，
優雅的引導開始會更明顯。

B<NOTE:> Older versions of
L<Catalyst::Model::DBIC::Schema> use the
deprecated DBIx::Class C<load_classes> technique instead of the newer
C<load_namespaces>.  For new applications, please try to use
C<load_namespaces> since it more easily supports a very useful DBIC
technique called "ResultSet Classes."  If you need to convert an
existing application from "load_classes" to "load_namespaces," you can
use this process to automate the migration, but first make sure you have
version C<0.39> of L<Catalyst::Model::DBIC::Schema> and
L<DBIx::Class::Schema::Loader> version C<0.05000> or later.

B<請注意：> 舊版本的 L<Catalyst::Model::DBIC::Schema> 使用棄用的 DBIx::Class C<load_classes> 技術而不是較新的 C<load_namespaces>。
對於新的應用程式，請使用 C<load_namespaces> 因為更加容易支援好用的 DBIC 技術 - 稱為 "結果類別 (ResultSet Classes)。"
如果您想要將現有使用 "load_classes" 的應用程式改成 "load_namespaces," 您可以使用下面的指令自動轉移，
但是前提示您要確認使用  L<Catalyst::Model::DBIC::Schema> C<0.39> 版本，以及 L<DBIx::Class::Schema::Loader> 版本 C<0.05000> 或更新。

    $ # Re-run the helper to upgrade for you
    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \
        create=static naming=current use_namespaces=1 \
        dbi:SQLite:myapp.db \
        on_connect_do="PRAGMA foreign_keys = ON"


=head1 ENABLE THE MODEL IN THE CONTROLLER

=head1 在控制器中啟用模型

Open F<lib/MyApp/Controller/Books.pm> and un-comment the model code we
left disabled earlier so that your version matches the following
(un-comment the line containing C<< [$c->model('DB::Book')->all] >>
and delete the next 2 lines):

打開 F<lib/MyApp/Controller/Books.pm> 並且去掉我們之前程式碼的註解，所以您現在程式的版本如下 
(去掉包含 C<< [$c->model('DB::Book')->all] >> 的註解及刪掉接下來 2 行)：

    =head2 list

    Fetch all book objects and pass to books/list.tt2 in stash to be displayed

    =cut

    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;

        # Retrieve all of the book records as book model objects and store
        # in the stash where they can be accessed by the TT template
        $c->stash(books => [$c->model('DB::Book')->all]);

        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (action methods respond to user input in
        # your controllers).
        $c->stash(template => 'books/list.tt2');
    }

B<TIP>: You may see the C<< $c->model('DB::Book') >> un-commented above
written as C<< $c->model('DB')->resultset('Book') >>.  The two are
equivalent.  Either way, C<< $c->model >> returns a
L<DBIx::Class::ResultSet> which handles queries
against the database and iterating over the set of results that is
returned.

B<提示>：您可能會看到 C<< $c->model('DB::Book') >> 要去掉的註解寫成 C<< $c->model('DB')->resultset('Book') >>。
這兩個是相同的。都是從 C<< $c->model >> 回傳 L<DBIx::Class::ResultSet> 來處理資料庫及將一整組回傳結果迭代完成。

We are using the C<< ->all >> to fetch all of the books.  DBIC supports
a wide variety of more advanced operations to easily do things like
filtering and sorting the results.  For example, the following could be
used to sort the results by descending title:

我們使用 C<< ->all >> 來獲取全部 books。
DBIC 支援廣泛進階的操作像是能夠容易地過濾 (filtering) 及排序 (sorting) 結果。
例如，下面範例降冪排序 title 結果：

    $c->model('DB::Book')->search({}, {order_by => 'title DESC'});

Some other examples are provided in
L<DBIx::Class::Manual::Cookbook/Complex WHERE clauses>, with additional
information found at L<DBIx::Class::ResultSet/search>,
L<DBIx::Class::Manual::FAQ/Searching>, L<DBIx::Class::Manual::Intro> and
L<Catalyst::Model::DBIC::Schema>.

其他的例子提供於 L<DBIx::Class::Manual::Cookbook/Complex WHERE clauses>, 更多資訊在 L<DBIx::Class::ResultSet/search>,
L<DBIx::Class::Manual::FAQ/Searching>, L<DBIx::Class::Manual::Intro> 及
L<Catalyst::Model::DBIC::Schema>。



=head2 Test Run The Application

=head2 測試運行應用程式

First, let's enable an environment variable that causes L<DBIx::Class>
to dump the SQL statements used to access the database.  This is a
helpful trick when you are trying to debug your database-oriented code.
Press C<Ctrl-C> to break out of the development server and enter:

首先，我們啟用一個環境變數讓 L<DBIx::Class> 傾印 SQL 資料庫存取狀態。
對於資料庫相關的程式除錯是個不錯的技巧。
輸入 C<Ctrl-C> 斷開開發伺服器並且輸入：


    $ export DBIC_TRACE=1
    $ script/myapp_server.pl -r

This assumes you are using bash as your shell -- adjust accordingly if
you are using a different shell (for example, under tcsh, use
C<setenv DBIC_TRACE 1>).

假設您是使用 bash 作為您的命令列終端 -- 根據您不同的終端稍作調整 (例如，tcsh 使用 C<setenv DBIC_TRACE 1>)。

B<NOTE:> You can also set this in your code using
C<< $class->storage->debug(1); >>.  See
L<DBIx::Class::Manual::Troubleshooting> for details (including options
to log to a file instead of displaying to the Catalyst development
server log).

B<請注意：> 您也可以在您的程式碼中使用 C<< $class->storage->debug(1); >>。
請看 L<DBIx::Class::Manual::Troubleshooting> 詳細介紹 
(包含日誌檔選項，而不是 Catalyst 開發伺服器日誌視窗顯示)。

Then launch the Catalyst development server.  The log output should
display something like:

接著運行 Catalyst 開發伺服其。日誌檔的輸出選項會如下顯示：

    $ script/myapp_server.pl -r
    [debug] Debug messages enabled
    [debug] Statistics enabled
    [debug] Loaded plugins:
    .----------------------------------------------------------------------------.
    | Catalyst::Plugin::ConfigLoader  0.30                                       |
    | Catalyst::Plugin::StackTrace  0.11                                         |
    '----------------------------------------------------------------------------'

    [debug] Loaded dispatcher "Catalyst::Dispatcher"
    [debug] Loaded engine "Catalyst::Engine"
    [debug] Found home "/home/catalyst/MyApp"
    [debug] Loaded Config "/home/catalyst/MyApp/myapp.conf"
    [debug] Loaded components:
    .-----------------------------------------------------------------+----------.
    | Class                                                           | Type     |
    +-----------------------------------------------------------------+----------+
    | MyApp::Controller::Books                                        | instance |
    | MyApp::Controller::Root                                         | instance |
    | MyApp::Model::DB                                                | instance |
    | MyApp::Model::DB::Author                                        | class    |
    | MyApp::Model::DB::Book                                          | class    |
    | MyApp::Model::DB::BookAuthor                                    | class    |
    | MyApp::View::HTML                                               | instance |
    '-----------------------------------------------------------------+----------'

    [debug] Loaded Private actions:
    .----------------------+--------------------------------------+--------------.
    | Private              | Class                                | Method       |
    +----------------------+--------------------------------------+--------------+
    | /default             | MyApp::Controller::Root              | default      |
    | /end                 | MyApp::Controller::Root              | end          |
    | /index               | MyApp::Controller::Root              | index        |
    | /books/index         | MyApp::Controller::Books             | index        |
    | /books/list          | MyApp::Controller::Books             | list         |
    '----------------------+--------------------------------------+--------------'

    [debug] Loaded Path actions:
    .-------------------------------------+--------------------------------------.
    | Path                                | Private                              |
    +-------------------------------------+--------------------------------------+
    | /                                   | /default                             |
    | /                                   | /index                               |
    | /books                              | /books/index                         |
    | /books/list                         | /books/list                          |
    '-------------------------------------+--------------------------------------'

    [info] MyApp powered by Catalyst 5.80020
    HTTP::Server::PSGI: Accepting connections at http://0:3000

B<NOTE:> Be sure you run the F<script/myapp_server.pl> command from the
'base' directory of your application, not inside the F<script> directory
itself or it will not be able to locate the F<myapp.db> database file.
You can use a fully qualified or a relative path to locate the database
file, but we did not specify that when we ran the model helper earlier.

B<請注意：>請確認運行協助腳本 F<script/myapp_server.pl> 在應用程式的基本目錄，
而不是在 F<script> 目錄中，這樣不能夠定位到 F<myapp.db> 資料庫檔案。
您可以指定完整路徑名稱也可以使用相對路徑指定資料庫檔案，
但是因為我們之前使用協助腳本產生的程式碼並沒有這樣指定。

Some things you should note in the output above:

先前的輸出有些值得您注意的是：

=over 4

=item *

L<Catalyst::Model::DBIC::Schema> dynamically created three model
classes, one to represent each of the three tables in our database
(C<MyApp::Model::DB::Author>, C<MyApp::Model::DB::BookAuthor>, and
C<MyApp::Model::DB::Book>).

L<Catalyst::Model::DBIC::Schema> 動態的產生 3 個模型檔案，每一個檔案分代表資料庫裡 3 個資料表欄位。
(C<MyApp::Model::DB::Author>, C<MyApp::Model::DB::BookAuthor>, 及 C<MyApp::Model::DB::Book>)。

=item *

The "list" action in our Books controller showed up with a path of
C</books/list>.

Books 控制器內的 "list" 動作顯示 C</books/list> 的路徑。

=back

Point your browser to L<http://localhost:3000> and you should still get
the Catalyst welcome page.

瀏覽器造訪 L<http://localhost:3000> 您應該還是會看到歡迎畫面。

Next, to view the book list, change the URL in your browser to
L<http://localhost:3000/books/list>. You should get a list of the five
books loaded by the F<myapp01.sql> script above without any formatting.
The rating for each book should appear on each row, but the "Author(s)"
column will still be blank (we will fill that in later).

接著，要查看書籍列表，瀏覽器改變 URL 為 L<http://localhost:3000/books/list>。
您應該會看到 5 個書籍載入，由 F<myapp01.sql> 腳本產生沒有格式化的結果。
每一個書籍的 rating 也會每列顯示，但是 "Author(s)" 欄位仍然是空白 (之後我們會填上)。

Also notice in the output of the F<script/myapp_server.pl> that
L<DBIx::Class> used the following SQL to retrieve the data:

請留意 F<script/myapp_server.pl> 使用 L<DBIx::Class> 的輸出，是使用下面的 SQL 獲取資料：

    SELECT me.id, me.title, me.rating FROM book me

because we enabled DBIC_TRACE.

因為我們啟用 DBIC_TRACE。


You now have the beginnings of a simple but workable web application.
Continue on to future sections and we will develop the application more
fully.

現在您得到了一個簡單初步的應用程式可以運行。
後續的章節我們讓應用程式更加完整。


=head1 CREATE A WRAPPER FOR THE VIEW

=head1 建立視圖包裹 (WRAPPER)

When using TT, you can (and should) create a wrapper that will literally
wrap content around each of your templates.  This is certainly useful as
you have one main source for changing things that will appear across
your entire site/application instead of having to edit many individual
files.

使用 TT，您可以 (應該) 建立一個包裹逐字地包裹住每個模板的內容。
必然有用的是，當您主要的原始碼有更動時可以遍及全站/應用程式而不是編輯各個獨立的檔案。

=head2 Configure HTML.pm For The Wrapper

=head2 設置 HTML.pm 包裹

In order to create a wrapper, you must first edit your TT view and tell
it where to find your wrapper file.

為了要建立包裹，首先您要編輯 TT 視圖並且告訴它何處搜尋您的包裹檔案。

Edit your TT view in F<lib/MyApp/View/HTML.pm> and change it to match
the following:

編輯 F<lib/MyApp/View/HTML.pm> 檔的 TT 視圖，改變如下：

    __PACKAGE__->config(
        # Change default TT extension
        TEMPLATE_EXTENSION => '.tt2',
        # Set the location for TT files
        INCLUDE_PATH => [
                MyApp->path_to( 'root', 'src' ),
            ],
        # Set to 1 for detailed timer stats in your HTML as comments
        TIMER              => 0,
        # This is your wrapper template located in the 'root/src'
        WRAPPER => 'wrapper.tt2',
    );


=head2 Create the Wrapper Template File and Stylesheet

=head2 建立模板檔案及樣規表包裹

Next you need to set up your wrapper template.  Basically, you'll want
to take the overall layout of your site and put it into this file.  For
the tutorial, open F<root/src/wrapper.tt2> and input the following:

接著您需要設定您的模板包裹。
簡單地，根據您期望的網頁整體版面放置需要的模板。
而本教學手冊，打開 F<root/src/wrapper.tt2> 輸入以下內容。

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" [%#
        %]"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <title>[% template.title or "My Catalyst App!" %]</title>
    <link rel="stylesheet" href="[% c.uri_for('/static/css/main.css') %]" />
    </head>

    <body>
    <div id="outer">
    <div id="header">
        [%# Your logo could go here -%]
        <img src="[% c.uri_for('/static/images/btn_88x31_powered.png') %]" />
        [%# Insert the page title -%]
        <h1>[% template.title or site.title %]</h1>
    </div>

    <div id="bodyblock">
    <div id="menu">
        Navigation:
        <ul>
            <li><a href="[% c.uri_for('/books/list') %]">Home</a></li>
            <li><a href="[% c.uri_for('/')
                %]" title="Catalyst Welcome Page">Welcome</a></li>
        </ul>
    </div><!-- end menu -->

    <div id="content">
        [%# Status and error messages %]
        <span class="message">[% status_msg %]</span>
        <span class="error">[% error_msg %]</span>
        [%# This is where TT will stick all of your template's contents. -%]
        [% content %]
    </div><!-- end content -->
    </div><!-- end bodyblock -->

    <div id="footer">Copyright (c) your name goes here</div>
    </div><!-- end outer -->

    </body>
    </html>

Notice the status and error message sections in the code above:

注意上面程式碼有關這 2 行錯誤訊息的部份：

    <span class="status">[% status_msg %]</span>
    <span class="error">[% error_msg %]</span>

If we set either message in the Catalyst stash (e.g.,
C<< $c->stash->{status_msg} = 'Request was successful!' >>) it will
be displayed whenever any view used by that request is rendered.  The
C<message> and C<error> CSS styles can be customized to suit your needs
in the F<root/static/css/main.css> file we create below.

如果我們設定錯誤訊息到 Catalyst stash 變數中 (例如 C<< $c->stash->{status_msg} = 'Request was successful!' >>) 
每次處理請求任何B<視圖呈現>後都會顯示這個訊息。
C<message> 和 C<error> 的 CSS 風格可以根據您的喜好在 F<root/static/css/main.css> 檔案中修改，如下。

B<Notes:>

B<附註：>

=over 4

=item *

The Catalyst stash only lasts for a single HTTP request.  If you need to
retain information across requests you can use
L<Catalyst::Plugin::Session> (we will use Catalyst sessions in the
Authentication chapter of the tutorial).

Catalyst stash 變數只會在單次請求中存在。如果您需要保持請求資訊您可以使用 L<Catalyst::Plugin::Session> 
(我們會在教學手冊認證章節中討論 Catalyst session)。

=item *

Although it is beyond the scope of this tutorial, you may wish to use a
JavaScript or AJAX tool such as jQuery (L<https://www.jquery.com>) or
Dojo (L<https://dojotoolkit.org/>).

雖然有些超出教學手冊的範圍，您可能會希望使用 JavaScript 或 AJAX 工具例如 JQuery (L<https://www.jquery.com>) 或 Dojo (L<https://dojotoolkit.org/>)。

=back


=head3 Create A Basic Stylesheet

=head4 建立簡單的樣規表

First create a central location for stylesheets under the static
directory:

首先建立一個靜態資料夾，集中管理樣規表檔案。

    $ mkdir root/static/css

Then open the file F<root/static/css/main.css> (the file referenced in
the stylesheet href link of our wrapper above) and add the following
content:

接著打開 F<root/static/css/main.css> 檔案 
(我們先前設定包裹時有設定樣規表的超連結參照) 然後加入下面內容。

    #header {
        text-align: center;
    }
    #header h1 {
        margin: 0;
    }
    #header img {
        float: right;
    }
    #footer {
        text-align: center;
        font-style: italic;
        padding-top: 20px;
    }
    #menu {
        font-weight: bold;
        background-color: #ddd;
    }
    #menu ul {
        list-style: none;
        float: left;
        margin: 0;
        padding: 0 0 50% 5px;
        font-weight: normal;
        background-color: #ddd;
        width: 100px;
    }
    #content {
        margin-left: 120px;
    }
    .message {
        color: #390;
    }
    .error {
        color: #f00;
    }

You may wish to check out a "CSS Framework" like Emastic
(L<http://code.google.com/p/emastic/>) as a way to quickly provide lots
of high-quality CSS functionality.

您可能會希望使用 "CSS 框架" 像是 Emastic (L<http://code.google.com/p/emastic/>) 
可以快速配置高品質的 CSS 功能。

=head2 Test Run The Application

=head2 測試運行應用程式

Hit "Reload" in your web browser and you should now see a formatted
version of our basic book list. (Again, the development server should
have automatically restarted when you made changes to
F<lib/MyApp/View/HTML.pm>. If you are not using the "-r" option, you
will need to hit C<Ctrl-C> and manually restart it. Also note that the
development server does I<NOT> need to restart for changes to the TT and
static files we created and edited in the C<root> directory -- those
updates are handled on a per-request basis.)

在您的瀏覽器中點擊 "重新載入" 您應該會看到美化後版本的簡單書籍列表。
(再次說明，開發伺服器應該會在您修改過 F<lib/MyApp/View/HTML.pm> 後自動重新啟動，
如果您啟動引數使用 "-r" 選項，您必須 C<Ctrl-C> 手動重新啟動。
也請注意開發伺服器I<沒有>必要因為修改過 C<root> 資料夾的 TT 及靜態檔案後重新啟動 -- 
會根據每次請求時更新。)

Although our wrapper and stylesheet are obviously very simple, you
should see how it allows us to control the overall look of an entire
website from two central files. To add new pages to the site, just
provide a template that fills in the C<content> section of our wrapper
template -- the wrapper will provide the overall feel of the page.

雖然我們的包裹及樣規表很明顯太陽春，您應該了解我們是使用哪 2 個中心檔案來控制網站的全面外觀。
要在網站新增頁面，只要在模板包裹內的 "content" HTML 標籤中提供您的模板檔案 -- 
包裹會呈現網頁全面的觀感。

=head2 Updating the Generated DBIx::Class Result Class Files

=head2 更新 Generated DBIx::Class 結果類別 (Result Class) 檔案

If you take a look at the Schema files automatically generated by
L<DBIx::Class::Schema::Loader>, you will see that it has already defined
C<has_many> and C<belongs_to> relationships on each side of our foreign
keys. For example, take a look at F<lib/MyApp/Schema/Result/Book.pm> and
notice the following code:

如果您查看 L<DBIx::Class::Schema::Loader> 自動產生的資料表設計綱要檔案，
您會看到 C<has_many> 及 C<belongs_to> 已經定義了各方面的外來鍵關聯。
例如，請查看 F<lib/MyApp/Schema/Result/Book.pm> 觀察下面程式碼：

    =head1 RELATIONS

    =head2 book_authors

    Type: has_many

    Related object: L<MyApp::Schema::Result::BookAuthor>

    =cut

    __PACKAGE__->has_many(
      "book_authors",
      "MyApp::Schema::Result::BookAuthor",
      { "foreign.book_id" => "self.id" },
      { cascade_copy => 0, cascade_delete => 0 },
    );

Each C<Book> "has_many" C<book_authors>, where C<BookAuthor> is the
many-to-many table that allows each Book to have multiple Authors, and
each Author to have multiple books.  The arguments to C<has_many> are:

每個 C<Book> 本身 "has_many" C<book_authors>, C<BookAuthor> 是多對多的表格，讓每本書可以有多個作者，
每個作者可以有多本書。 C<has_many> 的引數為：

=over 4

=item *

C<book_authors> - The name for this relationship.  DBIC will create an
accessor on the C<Books> DBIC Row object with this name.

C<book_authors> - 建立關聯的名稱。 DBIC 會使用這個名稱建立 C<Books> DBIC 列物件的存取器。

=item *

C<MyApp::Schema::Result::BookAuthor> - The name of the DBIC model class
referenced by this C<has_many> relationship.

C<MyApp::Schema::Result::BookAuthor> - C<has_many> 關聯參照到 DBIC 模型類別的名稱。

=item *

C<foreign.book_id> - C<book_id> is the name of the foreign key column in
the I<foreign> table that points back to this table.

C<foreign.book_id> - C<book_id> 是指向內部鍵的外部鍵欄位的名稱。

=item *

C<self.id> - C<id> is the name of the column in I<this> table that is
referenced by the foreign key.

C<self.id> - C<id> 為指向外部鍵的 I<this> 資料表欄位名稱。

=back

See L<DBIx::Class::Relationship/has_many> for additional information.
Note that you might see a "hand coded" version of the C<has_many>
relationship above expressed as:

請看 L<DBIx::Class::Relationship/has_many> 獲得更多資訊。
請注意您可能會看到有些版本 C<has_many> 的 "寫法"，如同上例子的關聯性：

    __PACKAGE__->has_many(
      "book_authors",
      "MyApp::Schema::Result::BookAuthor",
      "book_id",
    );

Where the third argument is simply the name of the column in the foreign
table.  However, the hashref syntax used by
L<DBIx::Class::Schema::Loader> is more flexible (for example, it can
handle "multi-column foreign keys").

第 3 個引數為外部鍵欄位的簡單寫法。
然而，雜湊參照語法在 L<DBIx::Class::Schema::Loader> 中更為彈性 (舉例來說，可以處理 "多欄外部鍵")。

B<Note:> If you are using older versions of SQLite and related DBIC
tools, you will need to manually define your C<has_many> and
C<belongs_to> relationships. We recommend upgrading to the versions
specified above. :-)

B<請注意：>如果您使用舊版本的 SQLite 及相應的 DBIC 工具，您必須手動定義您的 C<has_many> 及
C<belongs_to> 關聯。建議您更新到我們先前提到的版本。 :-)

Have a look at F<lib/MyApp/Schema/Result/BookAuthor.pm> and notice that
there is a C<belongs_to> relationship defined that acts as the "mirror
image" to the C<has_many> relationship we just looked at above:

查看 F<lib/MyApp/Schema/Result/BookAuthor.pm> 您會注意到 C<belongs_to> 
會 "鏡射" 關聯定義到先前定義的 C<has_many> 關聯，看起來如下：

    =head1 RELATIONS

    =head2 book

    Type: belongs_to

    Related object: L<MyApp::Schema::Result::Book>

    =cut

    __PACKAGE__->belongs_to(
      "book",
      "MyApp::Schema::Result::Book",
      { id => "book_id" },
      { join_type => "LEFT", on_delete => "CASCADE", on_update => "CASCADE" },
    );

The arguments are similar, but see
L<DBIx::Class::Relationship/belongs_to> for the details.

引數大致相同，但是請看 L<DBIx::Class::Relationship/belongs_to> 獲得更多資訊。

Although recent versions of SQLite and L<DBIx::Class::Schema::Loader>
automatically handle the C<has_many> and C<belongs_to> relationships,
C<many_to_many> relationship bridges (not technically a relationship)
currently need to be manually inserted.  To add a C<many_to_many>
relationship bridge, first edit F<lib/MyApp/Schema/Result/Book.pm> and
add the following text below the C<# You can replace this text...>
comment:

雖然近期版本的 SQLite 及 L<DBIx::Class::Schema::Loader> 自動處理 C<has_many> 及 C<belongs_to> 關聯，
C<多對多 (many_to_many)> 的關聯橋接目前還需要手動加入 (技術上不是關聯)。
要新增 C<many_to_many> 關聯橋接，首先編輯 F<lib/MyApp/Schema/Result/Book.pm> 及加入 C<# You can replace this text...> 註解之後的程式碼：


    # many_to_many():
    #   args:
    #     1) Name of relationship bridge, DBIC will create accessor with this name
    #     2) Name of has_many() relationship this many_to_many() is shortcut for
    #     3) Name of belongs_to() relationship in model class of has_many() above
    #   You must already have the has_many() defined to use a many_to_many().
    __PACKAGE__->many_to_many(authors => 'book_authors', 'author');

B<Note:> Be careful to put this code I<above> the C<1;> at the end of
the file.  As with any Perl package, we need to end the last line with a
statement that evaluates to C<true>.  This is customarily done with
C<1;> on a line by itself.

B<請注意：> I<上面>的程式請好好加入 C<1;> 在檔案末端，按照所有 Perl 套件，我們在最後一行回傳相等於  C<true> 的述句。
而 C<1;> 也是在單行結束的編寫慣例。

The C<many_to_many> relationship bridge is optional, but it makes it
easier to map a book to its collection of authors.  Without it, we would
have to "walk" through the C<book_author> table as in
C<< $book->book_author->first->author->last_name >> (we will
see examples on how to use DBIx::Class objects in your code soon, but
note that because C<< $book->book_author >> can return multiple authors,
we have to use C<first> to display a single author).  C<many_to_many>
allows us to use the shorter
C<< $book->author->first->last_name >>. Note that you cannot
define a C<many_to_many> relationship bridge without also having the
C<has_many> relationship in place.

C<many_to_many> 關聯橋接為可選的，但是可以讓每個 book 對映到一組 authors 更加方便。
如果沒有，我們必須 "遍歷" C<book_author> 所有的 C<< $book->book_author->first->author->last_name >> 
(之後會有例子，如何使用 DBIx::Class 物件，但是請記住因為 C<< $book->book_author >> 回傳多個作者，我們必須擷取C<開頭>的結果，來顯示唯一的作者)。
C<many_to_many> 可以較短地使用 C<< $book->author->first->last_name >>。
請注意您不能在沒有 C<has_many> 的情況使用 C<many_to_many> 關聯橋接。

Then edit F<lib/MyApp/Schema/Result/Author.pm> and add the reverse
C<many_to_many> relationship bridge for C<Author> as follows (again, be
careful to put in above the C<1;> but below the C<# DO NOT MODIFY THIS
OR ANYTHING ABOVE!> comment):

然後編輯 F<lib/MyApp/Schema/Result/Author.pm> 新增一個反向 C<many_to_many> 的 C<Author> 關聯橋接如下：
(再次提醒，請小心放置您的 C<1;> 在 C<# DO NOT MODIFY THIS OR ANYTHING ABOVE!> 註解之後)：

    # many_to_many():
    #   args:
    #     1) Name of relationship bridge, DBIC will create accessor with this name
    #     2) Name of has_many() relationship this many_to_many() is shortcut for
    #     3) Name of belongs_to() relationship in model class of has_many() above
    #   You must already have the has_many() defined to use a many_to_many().
    __PACKAGE__->many_to_many(books => 'book_authors', 'book');


=head2 Run The Application

=head2 運行您應用程式

Run the Catalyst development server script with the C<DBIC_TRACE> option
(it might still be enabled from earlier in the tutorial, but here is an
alternate way to specify the trace option just in case):

運行 Catalyst 開發伺服器，並且使用 C<DBIC_TRACE> 選項 
(先前的教學可能有啟用了，但是這裡有個替代方式指定跟蹤選項例子)：

    $ DBIC_TRACE=1 script/myapp_server.pl -r

Make sure that the application loads correctly and that you see the
three dynamically created model classes (one for each of the Result
Classes we created).

確保您的應用程式運行正確，且您會看到 3 個動態增加的模型類別 (每個我們增加過的結果類別 Result Classes)。

Then hit the URL L<http://localhost:3000/books/list> with your browser
and be sure that the book list still displays correctly.

用您的瀏覽器造訪 URL L<http://localhost:3000/books/list> 確認您的書籍依然顯示正確。

B<Note:> You will not see the authors yet because the view isn't taking
advantage of these relationships. Read on to the next section where we
update the template to do that.

B<請注意：>您還看不到作者，因為視圖元件還沒有效利用這些關聯。
閱讀後續的章節我們更新模板來做這件事。


=head1 UPDATING THE VIEW

=head1 更新視圖

Let's add a new column to our book list page that takes advantage of the
relationship information we manually added to our schema files in the
previous section.  Edit F<root/src/books/list.tt2> and replace the
"empty" table cell "C<< <td></td> >>" with the following:

我們根據先前章節手動增加的資料庫設計綱要檔案，利用關聯資訊的優勢新增我們的書籍列表頁。
編輯 F<root/src/books/list.tt2> 修改 "空白" 表格元素 "C<< <td></td> >>" 如下：

    ...
    <td>
      [% # NOTE: See Chapter 4 for a better way to do this!                      -%]
      [% # First initialize a TT variable to hold a list.  Then use a TT FOREACH -%]
      [% # loop in 'side effect notation' to load just the last names of the     -%]
      [% # authors into the list. Note that the 'push' TT vmethod doesn't return -%]
      [% # a value, so nothing will be printed here.  But, if you have something -%]
      [% # in TT that does return a value and you don't want it printed, you     -%]
      [% # 1) assign it to a bogus value, or                                     -%]
      [% # 2) use the CALL keyword to call it and discard the return value.      -%]
      [% tt_authors = [ ];
         tt_authors.push(author.last_name) FOREACH author = book.authors %]
      [% # Now use a TT 'virtual method' to display the author count in parens   -%]
      [% # Note the use of the TT filter "| html" to escape dangerous characters -%]
      ([% tt_authors.size | html %])
      [% # Use another TT vmethod to join & print the names & comma separators   -%]
      [% tt_authors.join(', ') | html %]
    </td>
    ...

B<IMPORTANT NOTE:> Again, you should keep as much "logic code" as
possible out of your views.  This kind of logic belongs in your model
(the same goes for controllers -- keep them as "thin" as possible and
push all of the "complicated code" out to your model objects).  Avoid
code like you see in the previous example -- we are only using it here
to show some extra features in TT until we get to the more advanced
model features we will see in Chapter 4 (see
L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>).

B<重要注意事項：>再次提醒，您應該讓您的B<視圖>盡可能保持 "邏輯程式碼"。
這種邏輯根據您的模型 (控制器也是同樣的道理 -- 盡可能保持 "輕巧" 並把 "複雜程式碼" 放在模型物件之外)。
避免像您看到的前一個例子 -- 我們使用它只是想要展示更多 TT 工具的功能，我們會展示更多的功能於第 4 章 
(請看 L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>)。

Then hit "Reload" in your browser (note that you don't need to reload
the development server or use the C<-r> option when updating TT
templates) and you should now see the number of authors each book has
along with a comma-separated list of the authors' last names.  (If you
didn't leave the development server running from the previous step, you
will obviously need to start it before you can refresh your browser
window.)

瀏覽器點選 "重新載入" 您應該會看到每本書有好幾個作者，以逗號分隔的作者名字 (請注意您如果使用 C<-r> 選項更新 TT 模板不需要重新載入開發伺服器)。
(如果您先前沒有讓開發伺服器保持運行，很明顯的您需要啟動它，在您用瀏覽器造訪以前。)

If you are still running the development server with C<DBIC_TRACE>
enabled, you should also now see five more C<SELECT> statements in the
debug output (one for each book as the authors are being retrieved by
DBIx::Class):

如果您持續運行開發伺服器並啟用 C<DBIC_TRACE>，您應該現在會看到 5 個以上 C<SELECT> 述句在您的除錯輸出 
(每一本書的作者由 DBIx::Class 獲取)：

    SELECT me.id, me.title, me.rating FROM book me:
    SELECT author.id, author.first_name, author.last_name FROM book_author me
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '1'
    SELECT author.id, author.first_name, author.last_name FROM book_author me
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '2'
    SELECT author.id, author.first_name, author.last_name FROM book_author me
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '3'
    SELECT author.id, author.first_name, author.last_name FROM book_author me
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '4'
    SELECT author.id, author.first_name, author.last_name FROM book_author me
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '5'

Also note in F<root/src/books/list.tt2> that we are using "| html", a
type of TT filter, to escape characters such as < and > to &lt;
and &gt; and avoid various types of dangerous hacks against your
application.  In a real application, you would probably want to put "|
html" at the end of every field where a user has control over the
information that can appear in that field (and can therefore inject
markup or code if you don't "neutralize" those fields).  In addition to
"| html", Template Toolkit has a variety of other useful filters that
can be found in the documentation for L<Template::Filters>.  (While we
are on the topic of security and escaping of dangerous values, one of
the advantages of using tools like DBIC for database access or
L<HTML::FormFu> for form management [see
L<Chapter 9|Catalyst::Manual::Tutorial::09_AdvancedCRUD::09_FormFu>]
is that they automatically handle most escaping for you and therefore
dramatically increase the security of your app.)

也請注意 F<root/src/books/list.tt2> 我們使用 "| html"，TT 的一種過濾器，讓一些特殊字元例如 < 和 > 轉換成 &lt; 及 &gt; 
可以讓您的應用程式免於各種形式的危險駭客。
在真實的應用程式中，您應該會想要用 "| html" 在每個欄位末端控制使用者表單欄位內可以顯示哪些資訊 
(此外也可以插入標記語言或程式碼您不無法 "中和" 的欄位字元)。
其他有關 "| html"，模板工具 (Template Toolkit) 可以發現各式各樣有用的過濾器，在說明文件 L<Template::Filters> 中。
(我們討論安全性及跳脫字元的不安全數值時，使用 DBIC 資料庫存取工具或 L<HTML::FormFu> 管理格式的一個優勢 [請看 L<Chapter 9|Catalyst::Manual::Tutorial::09_AdvancedCRUD::09_FormFu>]
可以自動處理大部分的跳脫字元，並且戲劇性的讓您的 app 更加安全。)


=head1 RUNNING THE APPLICATION FROM THE COMMAND LINE

=head1 在命令列運行應用程式

In some situations, it can be useful to run your application and display
a page without using a browser.  Catalyst lets you do this using the
F<script/myapp_test.pl> script.  Just supply the URL you wish to
display and it will run that request through the normal controller
dispatch logic and use the appropriate view to render the output
(obviously, complex pages may dump a lot of text to your terminal
window).  For example, if C<Ctrl+C> out of the development server
and then type:

在一些情況，運行您的應用程式不使用瀏覽器顯示您的頁面很有用。
Catalyst 可以使用 F<script/myapp_test.pl> 腳本達成。
只要提供您要顯示的 URL 給腳本，就會執行請求，並透過一般控制器邏輯分派，使用適當的視圖呈現輸出
(明顯地，複雜的頁面會在終端傾印大量的文字)。
下面例子，如果鍵盤輸入 C<Ctrl+C> 離開開發伺服器接著輸入：

    $ script/myapp_test.pl "/books/list"

You should get the same text as if you visited
L<http://localhost:3000/books/list> with the normal development server
and asked your browser to view the page source.  You can even pipe this
HTML text output to a text-based browser using a command like:

您應該會收到 L<http://localhost:3000/books/list> 相同的文字，
如同開發伺服器運行中，讓您瀏覽器觀看頁面內容。
您甚至可以用管道 (pipe) 輸出 HTML 內容，並且提供給終端為基礎的網頁瀏覽器使用，指令如下：

    $ script/myapp_test.pl "/books/list" | lynx -stdin

And you should see a fully rendered text-based view of your page.  (If
you are following along in Debian 6, type
C<sudo aptitude -y install lynx> to install lynx.)  If you do start
lynx, you can use the "Q" key to quit.

而您會看到完整呈現上色的網頁文字內容。
(如果您是在 Debian6 環境下，指令 C<sudo aptitude -y install lynx> 可以安裝 lynx。)
打開 lynx 瀏覽器，如果要離開輸入鍵盤 "Q"。

=head1 OPTIONAL INFORMATION

=head1 選項資訊

B<NOTE: The rest of this chapter of the tutorial is optional.  You can
skip to Chapter 4, L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>,
if you wish.>

B<請注意：本章剩餘部份是可選的。您可以依喜好直接跳到第 4 章，L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD> >

=head2 Using 'RenderView' for the Default View

=head2 使用 'RenderView' 作為預設視圖

Once your controller logic has processed the request from a user, it
forwards processing to your view in order to generate the appropriate
response output.  Catalyst uses
L<Catalyst::Action::RenderView> by default
to automatically perform this operation.  If you look in
F<lib/MyApp/Controller/Root.pm>, you should see the empty definition for
the C<sub end> method:

一旦您的控制器處理了使用者發出的請求，它會直接將程序轉發 (forwards) 到您的視圖，來產生適當的輸出。
Catalyst 預設使用 L<Catalyst::Action::RenderView> 自動執行這些運算。
如果您查詢 F<lib/MyApp/Controller/Root.pm> ，您會看到 C<sub end> 方法的定義是空的：

    sub end : ActionClass('RenderView') {}

The following bullet points provide a quick overview of the
C<RenderView> process:

以下的要點提供 C<RenderView> 程序的快速導覽：

=over 4

=item *

F<Root.pm> is designed to hold application-wide logic.

F<Root.pm> 設計上為整個應用程式範圍的邏輯。

=item *

At the end of a given user request, Catalyst will call the most specific
C<end> method that's appropriate.  For example, if the controller for a
request has an C<end> method defined, it will be called.  However, if
the controller does not define a controller-specific C<end> method, the
"global" C<end> method in F<Root.pm> will be called.

使用者請求的末端，Catalyst 會適當地呼叫最特別的方法 C<end>。
例如，如果控制器處理一個請求時 C<end> 方法有定義，它會被執行。
然而如果控制器沒有定義控制器 (controller-specific) 自己的 C<end> 方法，
F<Root.pm> 中 "全域 (global)" 的 C<end> 方法會被呼叫。

=item *

Because the definition includes an C<ActionClass> attribute, the
L<Catalyst::Action::RenderView> logic will be executed B<after> any code
inside the definition of C<sub end> is run.  See
L<Catalyst::Manual::Actions> for more information on C<ActionClass>.

因為這個定義包含 C<ActionClass> 屬性，L<Catalyst::Action::RenderView> 
邏輯會在所有 C<sub end> 內定義的程式執行完時，接著執行。
請看 L<Catalyst::Manual::Actions> 獲得更多有關 C<ActionClass> 的資訊。

=item *

Because C<sub end> is empty, this effectively just runs the default
logic in C<RenderView>.  However, you can easily extend the
C<RenderView> logic by adding your own code inside the empty method body
(C<{}>) created by the Catalyst Helpers when we first ran the
F<catalyst.pl> to initialize our application.  See
L<Catalyst::Action::RenderView> for more
detailed information on how to extend C<RenderView> in C<sub end>.

因為 C<sub end> 是空的，只是會有效執行預設邏輯 C<RenderView>。
然而，您可以簡單地擴充 C<RenderView> 邏輯，在使用 F<catalyst.pl> 初始化應用程式時，使用 Catalyst 協助腳本加入您自己的程式碼在空的方法內 (C<{}>)，
請看 L<Catalyst::Action::RenderView> 獲得更多詳細資訊有關 C<sub end> 中的 C<RenderView>。


=back


=head2 RenderView's "dump_info" Feature

=head2 RenderView "dump_info" 功能

One of the nice features of C<RenderView> is that it automatically
allows you to add C<dump_info=1> to the end of any URL for your
application and it will force the display of the "exception dump" screen
to the client browser.  You can try this out by pointing your browser to
this URL:

C<RenderView> 其中一個不錯的功能是，自動讓您在應用程式 URL 末端加上 C<dump_info=1>，
可以強制顯示 "額外的傾印" 畫面在瀏覽器中。
您可以嘗試使用瀏覽器指向下面 URL：

    http://localhost:3000/books/list?dump_info=1

You should get a page with the following message at the top:

您應該會得到下面的訊息在頁面上方：

    Caught exception in MyApp::Controller::Root->end "Forced debug -
    Scrubbed output at /usr/share/perl5/Catalyst/Action/RenderView.pm line 46."

Along with a summary of your application's state at the end of the
processing for that request.  The "Stash" section should show a
summarized version of the DBIC book model objects.  If desired, you can
adjust the summarization logic (called "scrubbing" logic) -- see
L<Catalyst::Action::RenderView> for
details.

連同您應用程式狀態的摘要，於請求程序的結束階段，"Stash" 部份應該會顯示 DBIC 書籍物件的摘要版本。
如果您需要，您可以調整摘要邏輯 (summarization logic) (稱為 "scrubbing" 邏輯) -- 請看 L<Catalyst::Action::RenderView> 獲得詳細資訊。

Note that you shouldn't need to worry about "normal clients" using this
technique to "reverse engineer" your application -- C<RenderView> only
supports the C<dump_info=1> feature when your application is running in
C<-Debug> mode (something you won't do once you have your application
deployed in production).

請注意您應該不需要擔心 "普通使用者" 使用這個技巧來讓您的應用程式 "反向工程" -- 
C<RenderView> 只會在您的應用程式為 C<-Debug> 模式時支援 C<dump_info=1> 功能
(當您的應用程式推上產品線後有些事不要做)。

=head2 Using The Default Template Name

=head2 使用預設模板名稱

By default, C<Catalyst::View::TT> will look for a template that uses the
same name as your controller action, allowing you to save the step of
manually specifying the template name in each action.  For example, this
would allow us to remove the
C<< $c->stash->{template} = 'books/list.tt2'; >>
line of our C<list> action in the Books controller.
Open C<lib/MyApp/Controller/Books.pm> in your editor and comment out
this line to match the following (only the
C<< $c->stash->{template} >> line has changed):

預設，C<Catalyst::View::TT> 會用控制器動作的名稱來搜尋模板，讓您省下為每個動作手動指定模板的名稱。
例如，我們的 Books 控制器裡的 C<list> 動作中，這一行可以刪除 C<< $c->stash->{template} = 'books/list.tt2'; >>。
編輯器打開 C<lib/MyApp/Controller/Books.pm>，把符合 C<< $c->stash->{template} >> 的那行註解掉：

    =head2 list

    Fetch all book objects and pass to books/list.tt2 in stash to be displayed

    =cut

    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;

        # Retrieve all of the book records as book model objects and store in the
        # stash where they can be accessed by the TT template
        $c->stash(books => [$c->model('DB::Book')->all]);

        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (actions methods respond to user input in
        # your controllers).
        #$c->stash(template => 'books/list.tt2');
    }


You should now be able to access the L<http://localhost:3000/books/list>
URL as before.

您應該可以和以前一樣存取 L<http://localhost:3000/books/list> URL。

B<NOTE:> If you use the default template technique, you
will B<not> be able to use either the C<< $c->forward >> or the
C<< $c->detach >> mechanisms (these are discussed in Chapter 2 and
Chapter 9 of the Tutorial).

B<請注意：> 如果您使用預設模板這個技巧，您也許B<不能>使用 C<< $c->forward >> 或 C<< $c->detach >> 的機制。
(教學手冊第 2 章及第 9 章討論過)。

B<IMPORTANT:> Make sure that you do B<not> skip the following section
before continuing to the next chapter 4 Basic CRUD.

B<重要：>請確保B<不要>跳過接下來的第 4 章 CRUD。


=head2 Return To A Manually Specified Template

=head2 回到手動指定模板

In order to be able to use C<< $c->forward >> and C<< $c->detach >>
later in the tutorial, you should remove the comment from the statement
in C<sub list> in F<lib/MyApp/Controller/Books.pm>:

為了能夠使用 C<< $c->forward >> 及 C<< $c->detach >> 於接下來的教學，F<lib/MyApp/Controller/Books.pm> 中讓 C<sub list> 取消註解：

    $c->stash(template => 'books/list.tt2');

Then delete the C<TEMPLATE_EXTENSION> line in F<lib/MyApp/View/HTML.pm>.

然後刪掉 F<lib/MyApp/View/HTML.pm> 中的 C<TEMPLATE_EXTENSION> 這行。

Check the L<http://localhost:3000/books/list> URL in your browser.  It
should look the same manner as with earlier sections.

瀏覽器檢查 L<http://localhost:3000/books/list> URL。
應該會看起來和前面章節一樣。


You can jump to the next chapter of the tutorial here:
L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>

您可以跳到教學手冊的這個章節：
L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>

=head1 AUTHOR

Kennedy Clark, C<hkclark@gmail.com>

Feel free to contact the author for any errors or suggestions, but the
best way to report issues is via the CPAN RT Bug system at
L<https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst-Manual>.

Copyright 2006-2011, Kennedy Clark, under the
Creative Commons Attribution Share-Alike License Version 3.0
(L<https://creativecommons.org/licenses/by-sa/3.0/us/>).
