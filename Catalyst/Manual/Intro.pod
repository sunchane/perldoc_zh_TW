=head1 NAME

Catalyst::Manual::Intro - Introduction to Catalyst
Catalyst::Manual::Intro - Catalyst 介紹

=head1 DESCRIPTION

This is a brief introduction to Catalyst. It explains the most important
features of how Catalyst works and shows how to get a simple application
up and running quickly. For an introduction (without code) to Catalyst
itself, and why you should be using it, see L<Catalyst::Manual::About>.
For a systematic step-by-step introduction to writing an application
with Catalyst, see L<Catalyst::Manual::Tuorial>.

本文是 Catalyst 簡明的介紹文件。
解釋 Catalyst 運行最重要的特性，並且為您展示如何快速建立簡單的網路應用程式並且運行。
另外有關 Catalyst 本身的介紹 (沒有程式碼)，以及為什麼您應該使用，請看 L<Catalyst::Manual::About>。
系統性逐步介紹 Catalyst 編寫網路應用程式，請看 L<Catalyst::Manual::Tuorial>。

=head2 What is Catalyst?

=head2 什麼是 Catalyst？

Catalyst is an elegant web application framework, extremely flexible
yet extremely simple. It's similar to Ruby on Rails, Spring (Java), and
L<Maypole>, upon which it was originally based. Its most
important design philosophy is to provide easy access to all the tools
you need to develop web applications, with few restrictions on how you
need to use these tools. However, this does mean that it is always
possible to do things in a different way. Other web frameworks are
I<initially> simpler to use, but achieve this by locking the programmer
into a single set of tools. Catalyst's emphasis on flexibility means
that you have to think more to use it. We view this as a feature.  For
example, this leads to Catalyst being better suited to system integration
tasks than other web frameworks.

Catalyst 是一個優雅的網路應用程式框架，極致彈性極致簡單。
跟 Ruby on Rails 類似，Spring (Java)，也很像 L<五朔節花柱>，做為原點的基礎。
最重要的設計哲學，是提供您各種容易使用的工具開發網頁應用程式，對工具的使用需求不受限制。
也就是說，一件事總有不同辦法可以完成。
其他的網頁框架首要通常是簡單使用，但是為了達成這個卻把程式設計師受困成一組固定的工具。
Catalyst 強調所謂的彈性是指您使用時可以有更多思考的空間，我們把這件事當作基本款。
例如，讓 Catalyst 成為更適合與作業系統整合而不是單純的網頁框架。

=head3 MVC

Catalyst follows the Model-View-Controller (MVC) design pattern,
allowing you to easily separate concerns, like content, presentation,
and flow control, into separate modules. This separation allows you to
modify code that handles one concern without affecting code that handles
the others. Catalyst promotes the re-use of existing Perl modules that
already handle common web application concerns well.

Catalyst 遵從模型-視圖-控制器 (MVC) 設計模式，讓您更容易達到關注點分離，
像是內容，表現，流程控制，成為區分的模組。
這種區分讓您修改程式碼時專注一部分而不會更動並影響到其他程式。
Catalyst 推廣現有 Perl 模組的重用，這些模組在常見的網路應用程式已經表現很好。

Here's how the Model, View, and Controller map to those concerns, with
examples of well-known Perl modules you may want to use for each.

這是有關模型-視圖-控制器對映到各自關注的部份，配合一些知名的 Perl 模組構成範例，
您常會需要用到。

=over 4

=item * B<Model>

Access and modify content (data). L<DBIx::Class>, L<Class::DBI>,
L<Xapian>, L<Net::LDAP>...

存取並且修改內容 (資料)。 L<DBIx::Class>, L<Class::DBI>,
L<Xapian>, L<Net::LDAP>...

=item * B<View>

Present content to the user. L<Template Toolkit|Template>,
L<Mason|HTML::Mason>, L<HTML::Template>...

瀏覽器使用者內容呈現。 L<Template Toolkit|Template>,
L<Mason|HTML::Mason>, L<HTML::Template>...

=item * B<Controller>

Control the whole request phase, check parameters, dispatch actions, flow
control. This is the meat of where Catalyst works.

控制所有的請求階段，檢查參數，發送動作，流程控制。這是 Catalyst 運行的主要部份。

=back

If you're unfamiliar with MVC and design patterns, you may want to
check out the original book on the subject, I<Design Patterns>, by
Gamma, Helm, Johnson, and Vlissides, also known as the Gang of Four
(GoF).  Many, many web application frameworks are based on MVC, which
is becoming a popular design paradigm for the world wide web.

如果您不熟悉 MVC 和設計框架，建議您可以去找這方面的原創，知名的四人幫 (GoF) 
Gamma, Helm, Johnson, 和 Vlissides 著作的 I<模式設計>。
很多很多的網頁程式框架根據 MVC，已經成為了網站流行的設計範式。

=head3 Flexibility

=head3 彈性

Catalyst is much more flexible than many other frameworks. Rest assured
you can use your favorite Perl modules with Catalyst.

Catalyst 比起其他的框架更加的彈性，剩下的就看您如何運用您熟悉的 Perl 套件來使用 Catalyst。

=over 4

=item * B<Multiple Models, Views, and Controllers>

=item * B<多重模組, 視點, 和控制器>

To build a Catalyst application, you handle each type of concern inside
special modules called L</Components>. Often this code will be very
simple, just calling out to Perl modules like those listed above under
L</MVC>. Catalyst handles these components in a very flexible way. Use
as many Models, Views, and Controllers as you like, using as many
different Perl modules as you like, all in the same application. Want to
manipulate multiple databases, and retrieve some data via LDAP? No
problem. Want to present data from the same Model using L<Template
Toolkit|Template> and L<PDF::Template>? Easy.

建置一個 Catalyst 應用程式，每一個您會關注的內部套件稱之為 L</元件>。
通常編寫程式很簡單，只要呼叫 Perl 模組如 L</MVC> 列出的。
Catalyst 處理這些元件的方式非常彈性。根據您要用多少模型，視圖，和控制器都可以，
要用多少 Perl 套件也都可以，所有東西都放在這個應用程式中。
想要控制多個資料庫，想要從 LDAP 取回資料？沒問題，想要用同個模型呈現 L<PDF::Template> 資料 
( L<模板工具|模板>)？簡單。

=item * B<Reuseable Components>

=item * B<可重用的元件>

Not only does Catalyst promote the re-use of already existing Perl
modules, it also allows you to re-use your Catalyst components in
multiple Catalyst applications.

不只 Catalyst 推廣重複使用現有的 Perl 套件，同時也允許您在不同的應用程式重用您的 Catalyst 元件。

=item * B<Unrestrained URL-to-Action Dispatching>

=item * B<不受限制的 URL-動作分派>

Catalyst allows you to dispatch any URLs to any application L</Actions>,
even through regular expressions! Unlike most other frameworks, it
doesn't require mod_rewrite or class and method names in URLs.

Catalyst 允許您分派各種 UML 到各種應用程式L<動作>，甚至是正規表達式！
不像大部分其他框架，URL 分派不需要 mod_rewrite 或類別及方法名稱。

With Catalyst you register your actions and address them directly. For
example:

註冊一個動作到 Catalyst 並且給予定址。例如：

    sub hello : Local {
        my ( $self, $context ) = @_;
        $context->response->body('Hello World!');
    }

Now http://localhost:3000/hello prints "Hello World!".

現在打開 http://localhost:3000/hello 印出 "Hello World!".

Note that actions with the C< :Local > attribute are equivalent to
using a C<:Path('action_name') > attribute, so our action could be
equivalently:

請注意動作包含 C< :Local > 屬性和使用 C< :Path('action_name') > 屬性相同，
所以下面的動作相同。

    sub hi : Path('hello') {
        my ( $self, $context ) = @_;
        $context->response->body('Hello World!');
    }


=item * B<Support for CGI, mod_perl, Apache::Request, FastCGI>

=item * B<支援 CGI，mod_perl，Apache::Request，FastCGI>

Use L<Catalyst::Engine::Apache> or L<Catalyst::Engine::CGI>. Another
interesting engine is L<Catalyst::Engine::HTTP::Prefork> - available from CPAN
separately - which will turn the built server into a fully fledged production
ready server (although you'll probably want to run it behind a front end proxy
if you end up using it).

使用 L<Catalyst::Engine::Apache> 或 L<Catalyst::Engine::CGI>。
其他有趣的模組 L<Catalyst::Engine::HTTP::Prefork> - 分別為不同 CPAN 模組，
可以讓您的網頁伺服器成為成熟的生產階段 (就算您的應用程式之前是運行在代理的後端，然而最後考慮使用)。

=item * PSGI Support

=item * PSGI 支援

Starting with Catalyst version 5.9 Catalyst ships with L<PSGI> integration
for even more powerful and flexible testing and deployment options.  See
L<Catalyst::PSGI> for details.

Catalyst 5.9 版之後隨附 L<PSGI> 於套件中，整合進更強大及彈性的測試及部屬選項。
請看 L<Catalyst::PSGI> 詳細資訊。

=back

=head3 Simplicity

=head3 簡易

The best part is that Catalyst implements all this flexibility in a very
simple way.

Catalyst 最棒的是以簡單的方式實踐了彈性。

=over 4

=item * B<Building Block Interface>

=item * B<建置區塊界面

Components interoperate very smoothly. For example, Catalyst
automatically makes a L</Context> object available to every
component. Via the context, you can access the request object, share
data between components, and control the flow of your
application. Building a Catalyst application feels a lot like snapping
together toy building blocks, and everything just works.

元件的協同能力非常流暢。例如，Catalyst 會為每一個元件建立 L</Context> 物件。
透過語境物件，您可以存取請求的物件，元件之間分享資料，及為您的應用程式設定控制流程。
建置 Catalyst 應用程式像是把樂高積木黏在一起，然後所有事情順利運作。

=item * B<Component Auto-Discovery>

=item * B<元件自動偵測>

No need to C<use> all of your components. Catalyst automatically finds
and loads them.

不需要 C<use> 您所有的元件，Catalyst 自動偵測及載入它們。

=item * B<Pre-Built Components for Popular Modules>

=item * B<使用熱門模組的內建元件>

See L<Catalyst::Model::DBIC::Schema> for L<DBIx::Class>, or
L<Catalyst::View::TT> for L<Template Toolkit|Template>.

請看 L<Catalyst::Model::DBIC::Schema> 模組 L<DBIx::Class>, 或
L<Catalyst::View::TT> 模組 L<Template Toolkit|Template>

=item * B<Built-in Test Framework>

=item * B<建置測試框架>

Catalyst comes with a built-in, lightweight http server and test
framework, making it easy to test applications from the web browser,
and the command line.

Catalyst 隨附內建輕巧的網頁伺服器及測試框架，讓您可以在網頁瀏覽器上或終端命令列上測試您的應用程式，

=item * B<Helper Scripts>

=item * B<協助腳本>

Catalyst provides helper scripts to quickly generate running starter
code for components and unit tests. Install L<Catalyst::Devel> and see
L<Catalyst::Helper>.

Catalyst 提供協助腳本讓您快速生成元件或單元測試的可啟動程式碼。
請安裝 L<Catalyst::Devel> 及請看 L<Catalyst::Helper>

=back

=head2 Quickstart

=head2 快速入門

Here's how to install Catalyst and get a simple application up and
running, using the helper scripts described above.

本節說明如何安裝 Catalyst 及建置一個簡單的應用程式並且運行，如前面敘述使用協助腳本達成。

=head3 Install

=head3 安裝

Installation of Catalyst should be straightforward:

安裝 Catalyst 應該很直觀：

    # perl -MCPAN -e 'install Catalyst::Runtime'
    # perl -MCPAN -e 'install Catalyst::Devel'
    # perl -MCPAN -e 'install Catalyst::View::TT'

=head3 Setup

=head3 設定

    $ catalyst.pl MyApp
    # output omitted
    $ cd MyApp
    $ script/myapp_create.pl controller Library::Login

=head4 Frank Speiser's Amazon EC2 Catalyst SDK

There are currently two flavors of publicly available Amazon Machine
Images (AMI) that include all the elements you'd need to begin
developing in a fully functional Catalyst environment within
minutes. See
L<Catalyst::Manual::Installation> for
more details.

目前有兩個不同特點的映像檔公開在 Amazon Machine Images (AMI)，包含所有您在開發時所有您需要的元件，
可讓您幾分鐘內建置全功能的 Catalyst 環境。
請看 L<Catalyst::Manual::Installation> 詳細介紹。

=head3 Run

=head3 運行

    $ script/myapp_server.pl

Now visit these locations with your favorite browser or user agent to see
Catalyst in action:

然後馬上用您最愛的瀏覽器造訪這個網址。

(NOTE: Although we create a controller here, we don't actually use it.
Both of these URLs should take you to the welcome page.)

(請注意：雖然我們新增了控制器，但我們事實上還沒用上。這 2 個 URL 都會帶您到歡迎畫面。)


=over 4

=item http://localhost:3000/

=item http://localhost:3000/library/login/

=back

=head2 How It Works

=head2 如何運作

Let's see how Catalyst works, by taking a closer look at the components
and other parts of a Catalyst application.

讓我們來看 Catalyst 如何運作，靠近瞧瞧元件及 Catalyst 應用程式的其他部份。

=head3 Components

=head3 元件

Catalyst has an uncommonly flexible component system. You can define as
many L</Models>, L</Views>, and L</Controllers> as you like. As discussed
previously, the general idea is that the View is responsible for the
output of data to the user (typically via a web browser, but a View can
also generate PDFs or e-mails, for example); the Model is responsible
for providing data (typically from a relational database); and the
Controller is responsible for interacting with the user and deciding
how user input determines what actions the application takes.

Catalyst 具有少見又彈性的元件系統。您可以定義愛定義多少 L</模型>, L</視圖>, 和 L</控制器> 都可以。
如前面討論過，視圖一般概念是為使用者輸出資料畫面 (通常是網頁瀏覽器，但是視圖也可以是 PDF 或 e-mail，舉例來說)；
模型職責為提供資料 (通常是關聯資料庫)；
而控制器的職責為與使用者互動及根據使用者的輸入決定應用程式的動作。

In the world of MVC, there are frequent discussions and disagreements
about the nature of each element - whether certain types of logic
belong in the Model or the Controller, etc. Catalyst's flexibility
means that this decision is entirely up to you, the programmer;
Catalyst doesn't enforce anything. See L<Catalyst::Manual::About> for
a general discussion of these issues.

世界上的 MVC 框架，經常討論和否定每個元件的生態 - 比如哪些類型的邏輯，應該歸於模型還是控制器。
Catalyst 的彈性將決定權完全讓給您，程式設計師；
Catalyst 不會強迫您任何事。請看 L<Catalyst::Manual::About>，這方面常見的討論議題。

Model, View and Controller components must inherit from L<Catalyst::Model>,
L<Catalyst::View> and L<Catalyst::Controller>, respectively. These, in turn, inherit
from L<Catalyst::Component> which provides a simple class structure and some
common class methods like C<config> and C<new> (constructor).

模型，視圖及控制器元件必須分別繼承自 L<Catalyst::Model>，L<Catalyst::View> 以及 L<Catalyst::Controller>，
反過來說，繼承自 L<Catalyst::Component> 
提供簡單的類別結構及一些常用的類別方法像是 C<config> 及 C<new> (建構子)。


    package MyApp::Controller::Catalog;
    use Moose;
    use namespace::autoclean;

    BEGIN { extends 'Catalyst::Controller' }

    __PACKAGE__->config( foo => 'bar' );

    1;

You don't have to C<use> or otherwise register Models, Views, and
Controllers.  Catalyst automatically discovers and instantiates them
when you call C<setup> in the main application. All you need to do is
put them in directories named for each Component type. You can use a
short alias for each one.

您不必使用 C<use> 或其他方法註冊模型，視圖，以及控制器。
Catalyst 在您主要的應用程式使用 C<setup> 指令會自動偵測並且實例化它們。
所有您要做的只是把程式放在正確的資料夾，並為各種型態的元件命名。
也可以為每個元件設定別名。

=over 4

=item * B<MyApp/Model/>

=item * B<MyApp/View/>

=item * B<MyApp/Controller/>

=back

=head4 Views
=head3 視圖

To show how to define views, we'll use an already-existing base class for the
L<Template Toolkit|Template>, L<Catalyst::View::TT>. All we need to do is
inherit from this class:

為了展示如何定義視圖，我們使用基礎類別 L<模板工具|模板>, L<Catalyst::View::TT>。
我們要做的全部只不過是繼承這個類別：

    package MyApp::View::TT;

    use strict;
    use base 'Catalyst::View::TT';

    1;

(You can also generate this automatically by using the helper script:

(您也可以使用協助腳本自動產生程式碼)

    script/myapp_create.pl view TT TT

where the first C<TT> tells the script that the name of the view should
be C<TT>, and the second that it should be a Template Toolkit view.)

第一個 C<TT> 告訴這個腳本視圖套件的名稱為 C<TT>，第二個 C<TT> 這個模組繼承自B<模板工具>的視圖模組。

This gives us a process() method and we can now just do
C<< $c->forward('MyApp::View::TT') >> to render our templates. The base class
makes process() implicit, so we don't have to say
C<< $c->forward(qw/MyApp::View::TT process/) >>.

這樣給我們的套件 process() 方法而我們可以使用 C<< $c->forward('MyApp::View::TT') >> 
呈現我們的模板。基礎類別 process() 為隱式方法，所以我們不能夠使用
C<< $c->forward(qw/MyApp::View::TT process/) >>。

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{template} = 'hello.tt';
    }

    sub end : Private {
        my ( $self, $c ) = @_;
        $c->forward( $c->view('TT') );
    }

You normally render templates at the end of a request, so it's a perfect
use for the global C<end> action.

您通常會在請求結束後呈現模板，所以使用全域方法 C<end> 動作最為適合。

In practice, however, you would use a default C<end> action as supplied
by L<Catalyst::Action::RenderView>.

實務上，您應該使用模組 L<Catalyst::Action::RenderView> 預設的 C<end> 動作。

Also, be sure to put the template under the directory specified in
C<< $c->config->{root} >>, or you'll end up looking at the debug
screen.

另外，請確定您把模板放在 C<< $c->config->{root} >> 指定的路徑，不然最後您會進到除錯模式。

=head4 Models

=head4 模型

Models are providers of data. This data could come from anywhere - a
search engine index, a spreadsheet, the file system - but typically a
Model represents a database table. The data source does not
intrinsically have much to do with web applications or Catalyst - it
could just as easily be used to write an offline report generator or a
command-line tool.

模型是資料的提供者。 資料可以來自於任何地方 - 搜尋器引擎目錄，試算表，檔案系統 - 
通常模型指的是資料庫的資料表。本質上，資料來源應該很少被網頁應用程式或 Catalyst 操作 - 
資料來源應該是一個簡單的離線報告產生器或命令列工具產生的。

To show how to define models, again we'll use an already-existing base
class, this time for L<DBIx::Class>: L<Catalyst::Model::DBIC::Schema>.
We'll also need L<DBIx::Class::Schema::Loader>.

為了展示定義模型，同樣的我們使用既有的基礎類別，輪到 L<DBIx::Class>: L<Catalyst::Model::DBIC::Schema> 
出場了，我們也需要 L<DBIx::Class::Schema::Loader>。

But first, we need a database.

但是一開始，我們需要資料庫。

    -- myapp.sql
    CREATE TABLE foo (
        id INTEGER PRIMARY KEY,
        data TEXT
    );

    CREATE TABLE bar (
        id INTEGER PRIMARY KEY,
        foo INTEGER REFERENCES foo,
        data TEXT
    );

    INSERT INTO foo (data) VALUES ('TEST!');

    % sqlite3 /tmp/myapp.db < myapp.sql

Now we can create a DBIC::Schema model for this database.

現在我們可以建立 DBIC::Schema 模型給這個資料庫

    script/myapp_create.pl model MyModel DBIC::Schema MySchema create=static 'dbi:SQLite:/tmp/myapp.db'

L<DBIx::Class::Schema::Loader> can automatically load table layouts and
relationships, and convert them into a static schema definition
C<MySchema>, which you can edit later.

L<DBIx::Class::Schema::Loader> 可以自動載入資料表格式和關聯，以及將它們轉換為欄位格式定義 C<MySchema>，
並且稍後編輯。

Use the stash to pass data to your templates.

使用 C<stash> 傳遞您的資料到您的模板

We add the following to MyApp/Controller/Root.pm

加入下面程式到 MyApp/Controller/Root.pm

    sub view : Global {
        my ( $self, $c, $id ) = @_;

        $c->stash->{item} = $c->model('MyModel::Foo')->find($id);
    }

    1;

    sub end : Private {
        my ( $self, $c ) = @_;

        $c->stash->{template} ||= 'index.tt';
        $c->forward( $c->view('TT') );
    }

We then create a new template file "root/index.tt" containing:

我們在新增一個模板檔案 "root/index.tt" 內容為：

    The Id's data is [% item.data %]

Models do not have to be part of your Catalyst application; you
can always call an outside module that serves as your Model:

模型不一定要包含您所有的 Catalyst 應用程式；您可以總是為您的模型呼叫外部的套件：

    # in a Controller
    sub list : Local {
      my ( $self, $c ) = @_;

      $c->stash->{template} = 'list.tt';

      use Some::Outside::Database::Module;
      my @records = Some::Outside::Database::Module->search({
        artist => 'Led Zeppelin',
        });

      $c->stash->{records} = \@records;
    }

But by using a Model that is part of your Catalyst application, you
gain several things: you don't have to C<use> each component, Catalyst
will find and load it automatically at compile-time; you can
C<forward> to the module, which can only be done to Catalyst
components.  Only Catalyst components can be fetched with
C<< $c->model('SomeModel') >>.

但是如果把您的 Catalyst 應用程式放在您的模型中，您可以有幾個好處：
您不需要 C<use> 元件，Catalyst 會在編譯期間自動偵測到並載入；您可以 C<forward> 這個模組，
也只有 Catalyst 元件可以做到。 另外只有 Catalyst 元件可以使用 C<< $c->model('SomeModel') >> 取用。

Happily, since many people have existing Model classes that they
would like to use with Catalyst (or, conversely, they want to
write Catalyst models that can be used outside of Catalyst, e.g.
in a cron job), it's trivial to write a simple component in
Catalyst that slurps in an outside Model:

令人高興的是，因為很多人有他既有的模型類別，在 Catalyst 中編寫簡單的元件非常容易，
只需要吞進外部的模型：

    package MyApp::Model::DB;
    use base qw/Catalyst::Model::DBIC::Schema/;
    __PACKAGE__->config(
        schema_class => 'Some::DBIC::Schema',
        connect_info => ['dbi:SQLite:foo.db', '', '', {AutoCommit=>1}]
    );
    1;

and that's it! Now C<Some::DBIC::Schema> is part of your
Cat app as C<MyApp::Model::DB>.

就這麼簡單！現在 C<Some::DBIC::Schema> 是您的 Catalyst C<MyApp::Model::DB> 應用程式套件的一員。


Within Catalyst, the common approach to writing a model for your
application is wrapping a generic model (e.g. L<DBIx::Class::Schema>, a
bunch of XMLs, or anything really) with an object that contains
configuration data, convenience methods, and so forth. Thus you
will in effect have two models - a wrapper model that knows something
about Catalyst and your web application, and a generic model that is
totally independent of these needs.

對於 Catalyst，您的應用程式編寫B<包裹通用模型>的B<模型>是個不錯的起步 (例如 L<DBIx::Class::Schema>, 一大堆 XML, 或任何真實的)，
這個模型包含組態資料，方便的方法，以及其他。所以您實際上會有兩個模型 - 對 Catalyst 及您的網頁應用程式有所了解的包裹模型，
以及完全獨立於程式需要的通用模型。

Technically, within Catalyst a model is a B<component> - an instance of
the model's class belonging to the application. It is important to
stress that the lifetime of these objects is per application, not per
request.

技術上來說，對於 Catalyst 模型就是一個 B<元件> - 模型類別實體化的物件後歸於這個應用程式。
強調重要的一點，這些物件的生命週期是以應用程式為單位，不是以請求為單位。

While the model base class (L<Catalyst::Model>) provides things like
C<config> to better integrate the model into the application, sometimes
this is not enough, and the model requires access to C<$c> itself.

模型的基礎類別 (L<Catalyst::Model>) 提供像是 C<config> 方法讓模型更容易整合進應用程式，
有時候功能上還是不足，並且模型需要存取 C<$c> 它自己。

Situations where this need might arise include:

下面舉例一些可能的需求情況：

=over 4

=item *

Interacting with another model

和其他模型整合

=item *

Using per-request data to control behavior

使用以每請求為單位的資料控制行為

=item *

Using plugins from a Model (for example L<Catalyst::Plugin::Cache>).

模型使用外掛 (例如 L<Catalyst::Plugin::Cache>)。

=back

From a style perspective it's usually considered bad form to make your
model "too smart" about things - it should worry about business logic
and leave the integration details to the controllers. If, however, you
find that it does not make sense at all to use an auxiliary controller
around the model, and the model's need to access C<$c> cannot be
sidestepped, there exists a power tool called L</ACCEPT_CONTEXT>.

從良好風格的觀點來看，讓您的模型對事情 "太聰明" 被認為是差勁的 - 
需要擔心這些商業邏輯和整合細節的工作交給B<控制器>。
您會發現對模型裝上輔助控制器是毫無意義的，並且不可避免的需要存取 C<$c>，
現有一個強大的工具稱之為 L</ACCEPT_CONTEXT>。

=head4 Controllers

=head4 控制器

Multiple controllers are a good way to separate logical domains of your
application.

多重的控制器是個區分應用程式和邏輯領域的好方法。

    package MyApp::Controller::Login;

    use base qw/Catalyst::Controller/;

    sub sign_in : Path("sign-in") { }
    sub new_password : Path("new-password") { }
    sub sign_out : Path("sign-out") { }

    package MyApp::Controller::Catalog;

    use base qw/Catalyst::Controller/;

    sub view : Local { }
    sub list : Local { }

    package MyApp::Controller::Cart;

    use base qw/Catalyst::Controller/;

    sub add : Local { }
    sub update : Local { }
    sub order : Local { }

Note that you can also supply attributes via the Controller's config so
long as you have at least one attribute on a subref to be exported
(:Action is commonly used for this) - for example the following is
equivalent to the same controller above:

請注意，您也可以提供參數給控制器的 C<config> 只要您有一個以上的參數於副程式參照需要輸出 (:Action 最常用在此) -
舉例來說下面的範例跟前一個範例相同：

    package MyApp::Controller::Login;

    use base qw/Catalyst::Controller/;

    __PACKAGE__->config(
      actions => {
        'sign_in' => { Path => 'sign-in' },
        'new_password' => { Path => 'new-password' },
        'sign_out' => { Path => 'sign-out' },
      },
    );

    sub sign_in : Action { }
    sub new_password : Action { }
    sub sign_out : Action { }

=head3 ACCEPT_CONTEXT

Whenever you call C<< $c->component("Foo") >> you get back an object - the
instance of the model. If the component supports the C<ACCEPT_CONTEXT>
method instead of returning the model itself, the return value of C<<
$model->ACCEPT_CONTEXT( $c ) >> will be used.

不論何時您呼叫了 C<< $c->component("Foo") >> 您得到了一個物件 - 模型的實體。
如果這個元件支援 C<ACCEPT_CONTEXT> 方法，而不是回傳這個模型本身，
回傳值 C<< $model->ACCEPT_CONTEXT( $c ) >> 會被使用。

This means that whenever your model/view/controller needs to talk to
C<$c> it gets a chance to do this when it's needed.

回傳值的意思是任何時候您的B<模型/視圖/控制器>如果有需要時可以提供機會和 C<$c> 進行溝通。

A typical C<ACCEPT_CONTEXT> method will either clone the model and return one
with the context object set, or it will return a thin wrapper that contains
C<$c> and delegates to the per-application model object.

典型的 C<ACCEPT_CONTEXT> 方法除了複製模型並且回傳物件語境，
也回傳包含 C<$c> 的包裹器代表這個應用程式模型物件。

Generally it's a bad idea to expose the context object (C<$c>) in your
model or view code.  Instead you use the C<ACCEPT_CONTEXT> subroutine
to grab the bits of the context object that you need, and provide
accessors to them in the model.  This ensures that C<$c> is only in
scope where it is needed which reduces maintenance and debugging
headaches.  So, if for example you needed two
L<Catalyst::Model::DBIC::Schema> models in the same Catalyst model
code, you might do something like this:

一般來說暴露您的語境物件 (C<$c>) 在模型或視圖的原始檔中不是個好辦法。
除非您使用 C<ACCEPT_CONTEXT> 副程式抓取語境物件需要的部份，為您的模型提供存取。
這樣確保 C<$c> 只會在您需要的命名空間中出現，並且減少維護及除錯的煩惱。
所以，舉例您需要 2 個模型 L<Catalyst::Model::DBIC::Schema> 在同個模型原始碼中，
您大概會這樣做：

 __PACKAGE__->mk_accessors(qw(model1_schema model2_schema));
 sub ACCEPT_CONTEXT {
     my ( $self, $c, @extra_arguments ) = @_;
     $self = bless({ %$self,
             model1_schema  => $c->model('Model1')->schema,
             model2_schema => $c->model('Model2')->schema
         }, ref($self));
     return $self;
 }

This effectively treats $self as a B<prototype object> that gets a new
parameter.  C<@extra_arguments> comes from any trailing arguments to
C<< $c->component( $bah, @extra_arguments ) >> (or C<< $c->model(...)
>>, C<< $c->view(...) >> etc).

這樣有效的處理 $self 為 B<原型物件> 獲得新的形參。
C<@extra_arguments> 接收來自
C<< $c->component( $bah, @extra_arguments ) >> 尾端剩下的引數 (或 C<< $c->model(...)
>>, C<< $c->view(...) >> 等等)。

In a subroutine in the  model code, we can then do this:
在模型原始碼的副程式中，我們可以這樣使用：

 sub whatever {
     my ($self) = @_;
     my $schema1 = $self->model1_schema;
     my $schema2 = $self->model2_schema;
     ...
 }

Note that we still want the Catalyst models to be a thin wrapper
around classes that will work independently of the Catalyst
application to promote reusability of code.  Here we might just want
to grab the C<< $c->model('DB')->schema >> so as to get the connection
information from the Catalyst application's configuration for example.

提醒您我們依然想讓 Catalyst 應用程式的模型，使用薄的類別包裹器來增加原始碼的重用性。
下面的例子是假如我們只想要抓取 C<< $c->model('DB')->schema >> 的連線資訊，
提供給 Catalyst 應用程式設定檔。

The life time of this value is B<per usage>, and not per request. To
make this per request you can use the following technique:

這個值的生命週期以每次使用為單位，而不是以請求為單位。
要變成以每次請求為單位您可以使用下面的技巧：

Add a field to C<$c>, like C<my_model_instance>. Then write your
C<ACCEPT_CONTEXT> method to look like this:

增加一個成員欄位 C<$c>，像是 C<my_model_instance>。
然後編寫您的 C<ACCEPT_CONTEXT> 方法像是這樣：

    sub ACCEPT_CONTEXT {
      my ( $self, $c ) = @_;

      if ( my $per_request = $c->my_model_instance ) {
        return $per_request;
      } else {
        my $new_instance = bless { %$self, c => $c }, ref($self);
        Scalar::Util::weaken($new_instance->{c}); # or we have a circular reference
        $c->my_model_instance( $new_instance );
        return $new_instance;
      }
    }

For a similar technique to grab a new component instance on each
request, see L<Catalyst::Component::InstancePerContext>.

以每次請求為單位抓取新的元件，類似的技巧，請看 L<Catalyst::Component::InstancePerContext>。


=head3 Application Class
=head3 應用程式類別

In addition to the Model, View, and Controller components, there's a
single class that represents your application itself. This is where you
configure your application, load plugins, and extend Catalyst.

除了模型，視圖，控制器元件，還有一個類別代表您應用程式本身。
這個類別是您修改設定檔的地方，載入外掛，以及擴充 Catalyst。

    package MyApp;

    use strict;
    use parent qw/Catalyst/;
    use Catalyst qw/-Debug ConfigLoader Static::Simple/;
    MyApp->config(
        name => 'My Application',

        # You can put anything else you want in here:
        my_configuration_variable => 'something',
    );
    1;

In older versions of Catalyst, the application class was where you put
global actions. However, as of version 5.66, the recommended practice is
to place such actions in a special Root controller (see L</Actions>,
below), to avoid namespace collisions.

較為舊版的 Catalyst，應用程式類別是您放置全域動作的地方。
此外，5.66 版以後，建議措施為放置這些動作在特殊的 Root 控制器中 (請看下面 L</Actions>)，
來避免名稱空間的衝突。

=over 4

=item * B<name>

=item * B<name>

The name of your application.

您的應用程式名稱

=back

Optionally, you can specify a B<root> parameter for templates and static
data.  If omitted, Catalyst will try to auto-detect the directory's
location. You can define as many parameters as you want for plugins or
whatever you need. You can access them anywhere in your application via
C<< $context->config->{$param_name} >>.

可選擇地，您可以為模板及靜態資料指定 B<root> 參數。如果略過，
Catalyst 會嘗試自動偵測資料夾路徑。
您可以定義任何數量的參數提供給外掛或任何您需要的地方。
您可以在您的應用程式中透過 C<< $context->config->{$param_name} >> 存取。

=head3 Context
=head3 語境

Catalyst automatically blesses a Context object into your application
class and makes it available everywhere in your application. Use the
Context to directly interact with Catalyst and glue your L</Components>
together. For example, if you need to use the Context from within a
Template Toolkit template, it's already there:

Catalyst 自動標定 (blesses) 語境物件至您的應用程式類別，並且讓它在您的應用程式任何地方可以使用。
使用語境讓您直接與 Catalyst 互動並且和您的 L</Components> 緊密黏合。
例如，如果您需要使用模板工具 (Template Toolkit) TT 模板，已在這：

    <h1>Welcome to [% c.config.name %]!</h1>

As illustrated in our URL-to-Action dispatching example, the Context is
always the second method parameter, behind the Component object
reference or class name itself. Previously we called it C<$context> for
clarity, but most Catalyst developers just call it C<$c>:

如先前我們的 URL-動作分派範例程式，語境總是我們第 2 個方法參數，隱藏在元件物件參照或類別名稱自己。
先前我們稱它為 C<$context> 明確些，大部分的 Catalyst 開發者稱它為 C<$c>。

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->res->body('Hello World!');
    }

The Context contains several important objects:

語境包含幾個重要的物件：

=over 4

=item * L<Catalyst::Request>

    $c->request
    $c->req # alias

The request object contains all kinds of request-specific information, like
query parameters, cookies, uploads, headers, and more.

請求物件包含各種關於請求的資訊，像是查詢參數 (query parameters)，cookies，uploads, headers, 及其他。

    $c->req->params->{foo};
    $c->req->cookies->{sessionid};
    $c->req->headers->content_type;
    $c->req->base;
    $c->req->uri_with( { page = $pager->next_page } );

=item * L<Catalyst::Response>

    $c->response
    $c->res # alias

The response is like the request, but contains just response-specific
information.

回應 (response) 像是請求，但是只包含回應相關的資訊。

    $c->res->body('Hello World');
    $c->res->status(404);
    $c->res->redirect('http://oook.de');

=item * config

    $c->config
    $c->config->{root};
    $c->config->{name};

=item * L<Catalyst::Log>

    $c->log
    $c->log->debug('Something happened');
    $c->log->info('Something you should know');

=item * B<Stash>

    $c->stash
    $c->stash->{foo} = 'bar';
    $c->stash->{baz} = {baz => 'qox'};
    $c->stash->{fred} = [qw/wilma pebbles/];

and so on.

以及其他。

=back

The last of these, the stash, is a universal hash for sharing data among
application components. For an example, we return to our 'hello' action:

最後一個，stash，是一個全域 (universal) 雜湊在應用程式元件之間分享資料。
舉例來說，我們回傳我們的 'hello' 動作：

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $c->forward('show_message');
    }

    sub show_message : Private {
        my ( $self, $c ) = @_;
        $c->res->body( $c->stash->{message} );
    }

Note that the stash should be used only for passing data in an
individual request cycle; it gets cleared at a new request. If you need
to maintain persistent data, use a session. See
L<Catalyst::Plugin::Session> for a comprehensive set of
Catalyst-friendly session-handling tools.

請注意 B<stash> 應該只用在個別請求循環時傳遞資料；新的請求時會清除。
如果您要維持不變的資料，使用 B<session>。
請看 L<Catalyst::Plugin::Session> 提供全面及對 Catalyst 友好的 B<session> 處理工具。

=head3 Actions
=head3 動作

You've already seen some examples of actions in this document:
subroutines with C<:Path> and C<:Local> attributes attached.
Here, we explain what actions are and how these attributes affect
what's happening.

您已經看過本文許多有關動作 (actions) 的例子：
副程式隨附 C<:Path> 及 C<:Local> 屬性。
這裡，我們來解釋什麼是動作，以及這些屬性如何影響及發生反應。

When Catalyst processes a webpage request, it looks for actions to
take that will deal with the incoming request and produce a response
such as a webpage.  You create these actions for your application by
writing subroutines within your controller and marking them with
special attributes.  The attributes, the namespace, and the function
name determine when Catalyst will call the subroutine.

當 Catalyst 處理網頁請求程序時，會查找動作來處理這個外來的請求，並且產生一個回應如網頁。
您為應用程式編寫副程式及控制器和設定特別的參數，來建立您的動作。
參數，名稱空間，及函式名稱指的是 Catalyst 呼叫的副程式。

These action subroutines call certain functions to say what response
the webserver will give to the web request.  They can also tell
Catalyst to run other actions on the request (one example of this is
called forwarding the request; this is discussed later).

這些動作副程式呼叫一些函式，產生提供給伺服器網頁請求的回應。
它們也可以告訴 Catalyst 對這個請求運行其他的動作 (其中一個例子是稱為轉發 forwarding 這個請求；稍後討論)。

Action subroutines must have a special attribute on to show that they
are actions - as well as marking when to call them, this shows that
they take a specific set of arguments and behave in a specific way.
At startup, Catalyst looks for all the actions in controllers,
registers them and creates L<Catalyst::Action> objects describing
them.  When requests come in, Catalyst chooses which actions should be
called to handle the request.

動作元件副程式必須有一個特別的參數來表示他是一個動作 - 只要設何時呼叫它的參數，
這代表它們需要一個特定的參數來表現特定的行為。
啟動時，Catalyst 搜尋控制器所有的動作元件，註冊它們並且建立 L<Catalyst::Action> 物件來敘述它。
當請求來時，Catalyst 選擇呼叫要處理這個請求的動作。

(Occasionally, you might use the action objects directly, but in
general, when we talk about actions, we're talking about the
subroutines in your application that do things to process a request.)

(經常地，您也可以直接使用動作物件，但通常，我們談的動作，
指的是您的應用程式處理請求時所使用的副程式。)

You can choose one of several attributes for action subroutines; these
specify which requests are processed by that subroutine.  Catalyst
will look at the URL it is processing, and the actions that it has
found, and automatically call the actions it finds that match the
circumstances of the request.

您可以選擇動作副程式的其中一種屬性；這樣指定處理副程式的那一種情求。
Catalyst 處理期間會監視 URL，然後發現這個動作，並且根據請求的情況自動呼叫這個動作。

The URL (for example C<http://localhost:3000/foo/bar>) consists of two
parts, the base, describing how to connect to the server
(C<http://localhost:3000/> in this example) and the path, which the
server uses to decide what to return (C<foo/bar>).  Please note that the
trailing slash after the hostname[:port] always belongs to base and
not to the path.  Catalyst uses only the path part when trying to find
actions to process.

URL (像是 C<http://localhost:3000/foo/bar>) 包含 2 個部份，基礎 (base)，
描述如何連線到伺服器 (C<http://localhost:3000/> 本範例) 以及路徑 (path)，
代表伺服器要回應什麼 (C<foo/bar>)。
請注意I<網址:阜>後面的斜線總是歸於B<網址>而不是屬於路徑 (path)。
Catalyst 只會使用路徑的部份來尋找處理的動作。

Depending on the type of action used, the URLs may match a combination
of the controller namespace, the arguments passed to the action
attribute, and the name of the subroutine.

根據被使用的動作種類，URL 也許會結合使用比對控制器名稱空間，傳遞給動作參數的引數，以及副程式的名稱。


=over 4

=item * B<Controller namespaces>

=item * B<控制器名稱空間>

The namespace is a modified form of the component's class (package)
name. This modified class name excludes the parts that have a
pre-defined meaning in Catalyst ("MyApp::Controller" in the above
example), replaces "::" with "/", and converts the name to lower case.
See L</Components> for a full explanation of the pre-defined meaning
of Catalyst component class names.

控制器的名稱空間根據元件類別名稱 (套件) 被修改。
被修改的類別名稱不能使用 Catalyst 預先定義或有特殊意義的名稱 (如前述的範例 "MyApp::Controller")，
取代 "::" 為 "/"，轉換為小寫。
請看 L</Components> 查閱詳細的解釋預先定義的 Catalyst 元件類別名稱。

=item * B<Overriding the namespace>

=item * B<複寫名稱空間>

Note that C<< __PACKAGE__->config->(namespace => ... ) >> can be used to override the
current namespace when matching.  So:

請注意  C<< __PACKAGE__->config->(namespace => ... ) >> 比對成功時可以覆寫目前的名稱空間。 所以：

    package MyApp::Controller::Example;

would normally use 'example' as its namespace for matching, but if
this is specially overridden with

正常地將 'example' 作為名稱空間，但是可以特別覆寫成

    __PACKAGE__->config( namespace => 'thing' );

it matches using the namespace 'thing' instead.

使用 'thing' 作為比對。

=item * B<Application-Wide Actions>

=item * B<應用程式範圍的動作元件>

MyApp::Controller::Root, as created by the catalyst.pl script, will
typically contain actions which are called for the top level of the
application (e.g. C<http://localhost:3000/>):

MyApp::Controller::Root，由 C<catalyst.pl> 腳本建置的，通常會包含頂層應用程式呼叫的動作 (例如 C<http://localhost:3000/>)：

    package MyApp::Controller::Root;
    use base 'Catalyst::Controller';

    # Sets the actions in this controller to be registered with no prefix
    # so they function identically to actions created in MyApp.pm

    __PACKAGE__->config( namespace => '');

    sub default : Path  {
        my ( $self, $context ) = @_;
        $context->response->status(404);
        $context->response->body('404 not found');
    }

    1;


The code

這一段程式

    __PACKAGE__->config( namespace => '' );

makes the controller act as if its namespace is empty.  As you'll see
below, an empty namespace makes many of the URL-matching attributes, such
as :Path and :Local match at the start of the URL path (i.e. the
application root).

這段程式說明如果名稱空間為空的運行下面這些控制器動作。
如您看到後續的程式，這個空的名稱空間設置許多 URL 比對的參數，
比如說 B<:Path> 及 B<:Local> 比對 URL 路徑的起點 (換句話說就是應用程式的根目錄)

=back

=head4 Action types

=head4 動作元件類型

Catalyst supports several types of actions.  These mainly correspond
to ways of matching a URL to an action subroutine.  Internally, these
matching types are implemented by L<Catalyst::DispatchType>-derived
classes; the documentation there can be helpful in seeing how they
work.

Catalyst 支援幾種類型的動作。
主要為比對 URL 到相應的動作副程式之方式。
內部來說，這些比對類型是由 L<Catalyst::DispatchType>-衍生的類別來實做；
這個說明文件對於了解運作的方式很有幫助。

They will all attempt to match the start of the path.  The remainder
of the path is passed as arguments.

它們一開始都會嘗試比對路徑的開頭。
剩下的路徑用引數傳遞。

=over 4

=item * Namespace-prefixed (C<:Local>)

=item * 名稱空間-前輟 (C<:Local>)

    package MyApp::Controller::My::Controller;
    sub foo : Local { }

Matches any URL beginning with> C<http://localhost:3000/my/controller/foo>. The namespace and
subroutine name together determine the path.

會比對以 C<http://localhost:3000/my/controller/foo> 開頭的 URL。
名稱空間和副程式名稱合在一起成為B<網址> (path)。

=item * Root-level (c<:global>)

=item * 根目錄-層級 (c<:global>)

    package MyApp::Controller::Foo;

    sub bar : Global {
        my ($self, $c) = @_;
        $c->res->body(
          $c->res->body('sub bar in Controller::Foo triggered on a request for '
                         . $c->req->uri));
    }

1;

Matches C<http://localhost:3000/bar> - that is, the action is mapped
directly to the method name, ignoring the controller namespace.

會比對 C<http://localhost:3000/bar> URL - 總而言之，動作直接映射到方法名稱，
忽落控制器模組類別名稱空間

C<:Global> always matches from the application root: it is simply
shorthand for C<:Path('/methodname')>.  C<:Local> is shorthand for
C<:Path('methodname')>, which takes the controller namespace as described
above.

C<:Global> 總是比對到應用程式的根目錄：簡單的速記為 C<:Path('/methodname')>， 
C<:Local> 速記為 C<:Path('methodname')>，這讓控制器名稱空間 (方法) 與上述的方法副程式相同。

Usage of the C<Global> handler is rare in all but very old Catalyst
applications (e.g. before Catalyst 5.7).  The use cases where C<Global>
used to make sense are now largely replaced by the C<Chained> dispatch
type, or by empty C<Path> declarations on an controller action.  C<Global>
is still included in Catalyst for backwards compatibility, although
legitimate use-cases for it may still exist.

C<Global> 操作的使用除了舊版本的 Catalyst 其他很少使用 (例如 Catalyst 5.7 版以前)。
C<Global> 的以前有意義的用例，現在已經大幅度的被 C<Chained> 分派類型給取代，
或是被動作控制器空白的 C<Path> 宣告給取代。
C<Global> 依然包含在 Catalyst 中為了向下相容，雖然舊版合理的用例依然存在。

=item * Changing handler behaviour: eating arguments (C<:Args>)

=item * 變更操作行為：吃下引數 (C<Args>)

C<:Args> is not an action type per se, but an action modifier - it adds a
match restriction to any action it's provided to, additionally
requiring as many path parts as are specified for the action to be
matched. For example, in MyApp::Controller::Foo,

C<:Args> 本身不是一個動作，而是動作的修飾器 - 它增加B<比對>的B<約束>並提供給任何動作使用，
此外請求與指定的部份路徑批配操作一樣多。範例，於 MyApp::Controller::Foo。

  sub bar :Local

would match any URL starting /foo/bar. To restrict this you can do

會匹配開頭為 /foo/bar 的路徑。約束可以使用

  sub bar :Local :Args(1)

to only match URLs starting /foo/bar/* - with one additional path
element required after 'bar'.

只有 /foo/bar/* 的 URL 會批配成功 - 只能在 'bar' 路徑後面增加一個路徑 

NOTE that adding C<:Args(0)> and omitting C<:Args> are B<not>
the same thing.

請注意加入 C<:Args(0)>和省略參數 C<:Args> B<並不是> 指同一件事。

C<:Args(0)> means that no arguments are taken.  Thus, the URL and path must
match precisely.

C<:Args(0)> 指的是沒有加入參數的情況。所以，URL 及路徑必須明確的比對才能批配。

No C<:Args> at all means that B<any number> of arguments are taken.  Thus, any
URL that B<starts with> the controller's path will match. Obviously, this means
you cannot chain from an action that does not specify args, as the next action
in the chain will be swallowed as an arg to the first!

不使用 C<:Args> 指的是容許使用B<任何的數字>為參數。
所以，任何 URL B<開頭>為任何控制器路徑都會匹配。明顯地，
這意味著您不能不指定動作的參數進行鏈接，
鍵接的下個動作會被當成第一個引數吞入！

=item * Literal match (C<:Path>)

=item * 字面匹配 (C<:Path>)

C<Path> actions match things starting with a precise specified path,
and nothing else.

C<Path> 動作匹配明確精準的指定路徑，而沒其他多餘的。

C<Path> actions without a leading forward slash match a specified path
relative to their current namespace. This example matches URLs
starting with C<http://localhost:3000/my/controller/foo/bar>:

C<Path> 動作沒有包含開頭的斜線代表指定的路徑在目前名稱空間之下。
範例批配 URL 開頭為 C<http://localhost:3000/my/controller/foo/bar>：

    package MyApp::Controller::My::Controller;
    sub bar : Path('foo/bar') { }

C<Path> actions B<with> a leading slash ignore their namespace, and
match from the start of the URL path. Example:

C<Path> 動作開頭B<包含>斜線忽略掉名稱空間，匹配網址之後開頭的路徑。範例：

    package MyApp::Controller::My::Controller;
    sub bar : Path('/foo/bar') { }

This matches URLs beginning with C<http://localhost:3000/foo/bar>.

這代表匹配 URL 開頭為 C<http://localhost:3000/foo/bar>。

Empty C<Path> definitions match on the namespace only, exactly like
C<:Global>.

空的 C<Path> 定義只匹配名稱空間而已，跟 C<:Global> 一模一樣。

    package MyApp::Controller::My::Controller;
    sub bar : Path { }

The above code matches C<http://localhost:3000/my/controller>.

上面這個程式匹配 C<http://localhost:3000/my/controller>。


Actions with the C<:Local> attribute are similarly equivalent to
C<:Path('action_name')>:

C<:Local> 的動作參數跟 C<:Path('action_name')> 同等類似。

    sub foo : Local { }

is equivalent to

與下方範例同等

    sub foo : Path('foo') { }

=item * Pattern match (C<:Regex> and C<:LocalRegex>)

=item * 正規表達式樣本匹配 (C<:Regex> 和 C<:LocalRegex>)

B<Status: deprecated.> Use Chained methods or other techniques.
If you really depend on this, install the standalone
L<Catalyst::DispatchType::Regex> distribution.

B<狀態：棄用。> 請使用其他鏈接方法或其他技巧。
如果您真的依賴這個，請獨立安裝 L<Catalyst::DispatchType::Regex> 發行版。 

    package MyApp::Controller::My::Controller;
    sub bar : Regex('^item(\d+)/order(\d+)$') { }

This matches any URL that matches the pattern in the action key, e.g.
C<http://localhost:3000/item23/order42>. The '' around the regexp is
optional, but perltidy likes it. :)

會匹配任何以正規表達式成功匹配樣本的 URL，例如 C<http://localhost:3000/item23/order42>。
'' 單引號是可選的，但是 perltidy 套件特別愛這個。 :)

C<:Regex> matches act globally, i.e. without reference to the namespace
from which they are called.  So the above will B<not> match
C<http://localhost:3000/my/controller/item23/order42> - use a
C<:LocalRegex> action instead.

    package MyApp::Controller::My::Controller;
    sub bar : LocalRegex('^widget(\d+)$') { }

C<:LocalRegex> actions act locally, i.e. the namespace is matched
first. The above example would match urls like
C<http://localhost:3000/my/controller/widget23>.

If you omit the "C<^>" from either sort of regex, then it will match any depth
from the base path:

    package MyApp::Controller::Catalog;
    sub bar : LocalRegex('widget(\d+)$') { }

This differs from the previous example in that it will match
C<http://localhost:3000/my/controller/foo/widget23> - and a number of
other paths.

For both C<:LocalRegex> and C<:Regex> actions, if you use capturing
parentheses to extract values within the matching URL, those values
are available in the C<< $c->req->captures >> array. In the above
example, "widget23" would capture "23" in the above example, and
C<< $c->req->captures->[0] >> would be "23". If you want to
pass arguments at the end of your URL, you must use regex action
keys. See L</URL Path Handling> below.

=item * Chained handlers (C<:Chained>)

Catalyst also provides a method to build and dispatch chains of actions,
like

    sub catalog : Chained : CaptureArgs(1) {
        my ( $self, $c, $arg ) = @_;
        ...
    }

    sub item : Chained('catalog') : Args(1) {
        my ( $self, $c, $arg ) = @_;
        ...
    }

to handle a C</catalog/*/item/*> path.  Matching actions are called
one after another - C<catalog()> gets called and handed one path
element, then C<item()> gets called with another one.  For further
information about this dispatch type, please see
L<Catalyst::DispatchType::Chained>.

=item * B<Private>

    sub foo : Private { }

This will never match a URL - it provides a private action which can
be called programmatically from within Catalyst, but is never called
automatically due to the URL being requested.

Catalyst's C<:Private> attribute is exclusive and doesn't work with other
attributes (so will not work combined with C<:Path> or C<:Chained>
attributes, for instance).

Private actions can only be executed explicitly from inside a Catalyst
application.  You might do this in your controllers by calling
catalyst methods such as C<forward> or C<detach> to fire them:

    $c->forward('foo');
    # or
    $c->detach('foo');

See L</Flow Control> for a full explanation of how you can pass
requests on to other actions. Note that, as discussed there, when
forwarding from another component, you must use the absolute path to
the method, so that a private C<bar> method in your
C<MyApp::Controller::Catalog::Order::Process> controller must, if
called from elsewhere, be reached with
C<< $c->forward('/catalog/order/process/bar') >>.

=back

B<Note:> After seeing these examples, you probably wonder what the
point is of defining subroutine names for regex and path
actions. However, every public action is also a private one with a
path corresponding to its namespace and subroutine name, so you have
one unified way of addressing components in your C<forward>s.

=head4 Built-in special actions

If present, the special actions C< index >, C< auto >, C<begin>,
C<end> and C< default > are called at certain points in the request
cycle.

In response to specific application states, Catalyst will automatically
call these built-in actions in your application class:

=over 4

=item * B<default : Path>

This is called when no other action matches. It could be used, for
example, for displaying a generic frontpage for the main app, or an
error page for individual controllers. B<Note>: in older Catalyst
applications you will see C<default : Private> which is roughly
speaking equivalent.


=item * B<index : Path : Args (0) >

C<index> is much like C<default> except that it takes no arguments and
it is weighted slightly higher in the matching process. It is useful
as a static entry point to a controller, e.g. to have a static welcome
page. Note that it's also weighted higher than Path.  Actually the sub
name C<index> can be called anything you want.  The sub attributes are
what determines the behaviour of the action.  B<Note>: in older
Catalyst applications, you will see C<index : Private> used, which is
roughly speaking equivalent.

=item * B<begin : Private>

Called at the beginning of a request, once the controller that will
run has been identified, but before any URL-matching actions are
called.  Catalyst will call the C<begin> function in the controller
which contains the action matching the URL.

=item * B<end : Private>

Called at the end of a request, after all URL-matching actions are called.
Catalyst will call the C<end> function in the controller
which contains the action matching the URL.

=item * B<auto : Private>

In addition to the normal built-in actions, you have a special action
for making chains, C<auto>. C<auto> actions will be run after any
C<begin>, but before your URL-matching action is processed. Unlike the other
built-ins, multiple C<auto> actions can be called; they will be
called in turn, starting with the application class and going through
to the most specific class.

=back

=head4 Built-in actions in controllers/autochaining

    package MyApp::Controller::Foo;
    sub begin : Private { }
    sub default : Path  { }
    sub end : Path  { }

You can define built-in actions within your controllers as well as on
your application class. In other words, for each of the three built-in
actions above, only one will be run in any request cycle. Thus, if
C<MyApp::Controller::Catalog::begin> exists, it will be run in place
of C<MyApp::begin> if you're in the C<catalog> namespace, and
C<MyApp::Controller::Catalog::Order::begin> would override this in
turn.

    sub auto : Private { }

C<auto>, however, doesn't override like this: providing they exist,
C<MyApp::Controller::Root::auto>, C<MyApp::Controller::Catalog::auto> and
C<MyApp::Catalog::Order::auto> would be called in turn.

Here are some examples of the order in which the various built-ins
would be called:

=over 4

=item for a request for C</foo/foo>

  MyApp::Controller::Foo::auto
  MyApp::Controller::Foo::default # in the absence of MyApp::Controller::Foo::Foo
  MyApp::Controller::Foo::end

=item for a request for C</foo/bar/foo>

  MyApp::Controller::Foo::Bar::begin
  MyApp::Controller::Foo::auto
  MyApp::Controller::Foo::Bar::auto
  MyApp::Controller::Foo::Bar::default # for MyApp::Controller::Foo::Bar::foo
  MyApp::Controller::Foo::Bar::end

=back

The C<auto> action is also distinguished by the fact that you can break
out of the processing chain by returning 0. If an C<auto> action returns
0, any remaining actions will be skipped, except for C<end>. So, for the
request above, if the first auto returns false, the chain would look
like this:

=over 4

=item for a request for C</foo/bar/foo> where first C<auto> returns
false

  MyApp::Controller::Foo::Bar::begin
  MyApp::Controller::Foo::auto # returns false, skips some calls:
  # MyApp::Controller::Foo::Bar::auto - never called
  # MyApp::Controller::Foo::Bar::foo - never called
  MyApp::Controller::Foo::Bar::end

You can also C<die> in the auto action; in that case, the request will
go straight to the finalize stage, without processing further
actions. So in the above example, C<MyApp::Controller::Foo::Bar::end>
is skipped as well.

=back

An example of why one might use C<auto> is an authentication action:
you could set up a C<auto> action to handle authentication in your
application class (which will always be called first), and if
authentication fails, returning 0 would skip any remaining methods for
that URL.

B<Note:> Looking at it another way, C<auto> actions have to return a
true value to continue processing!

=head4 URL Path Handling

You can pass arguments as part of the URL path, separated with forward
slashes (/). If the action is a Regex or LocalRegex, the '$' anchor
must be used. For example, suppose you want to handle
C</foo/$bar/$baz>, where C<$bar> and C<$baz> may vary:

    sub foo : Regex('^foo$') { my ($self, $context, $bar, $baz) = @_; }

But what if you also defined actions for C</foo/boo> and C</foo/boo/hoo>?

    sub boo : Path('foo/boo') { .. }
    sub hoo : Path('foo/boo/hoo') { .. }

Catalyst matches actions in most specific to least specific order - that is, whatever matches the most pieces of the path wins:

    /foo/boo/hoo
    /foo/boo
    /foo # might be /foo/bar/baz but won't be /foo/boo/hoo

So Catalyst would never mistakenly dispatch the first two URLs to the
'^foo$' action.

If a Regex or LocalRegex action doesn't use the '$' anchor, the action will
still match a URL containing arguments; however the arguments won't be
available via C<@_>, because the Regex will 'eat' them.

Beware!  If you write two matchers, that match the same path, with the
same specificity (that is, they match the same quantity of the path),
there's no guarantee which will actually get called.  Non-regex
matchers get tried first, followed by regex ones, but if you have, for
instance:

   package MyApp::Controller::Root;

   sub match1 :Path('/a/b') { }

   package MyApp::Controller::A;

   sub b :Local { } # Matches /a/b

then Catalyst will call the one it finds first.  In summary, Don't Do
This.

=head4 Query Parameter Processing

Parameters passed in the URL query string are handled with methods in
the L<Catalyst::Request> class. The C<param> method is functionally
equivalent to the C<param> method of L<CGI.pm|CGI> and can be used in
modules that require this.

    # http://localhost:3000/catalog/view/?category=hardware&page=3
    my $category = $c->req->param('category');
    my $current_page = $c->req->param('page') || 1;

    # multiple values for single parameter name
    my @values = $c->req->param('scrolling_list');

    # DFV requires a CGI.pm-like input hash
    my $results = Data::FormValidator->check($c->req->params, \%dfv_profile);

=head3 Flow Control

You control the application flow with the C<forward> method, which
accepts the key of an action to execute. This can be an action in the
same or another Catalyst controller, or a Class name, optionally
followed by a method name. After a C<forward>, the control flow will
return to the method from which the C<forward> was issued.

A C<forward> is similar to a method call. The main differences are that
it wraps the call in an C<eval> to allow exception handling; it
automatically passes along the context object (C<$c> or C<$context>);
and it allows profiling of each call (displayed in the log with
debugging enabled).

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $c->forward('check_message'); # $c is automatically included
    }

    sub check_message : Private {
        my ( $self, $c ) = @_;
        return unless $c->stash->{message};
        $c->forward('show_message');
    }

    sub show_message : Private {
        my ( $self, $c ) = @_;
        $c->res->body( $c->stash->{message} );
    }

A C<forward> does not create a new request, so your request object
(C<< $c->req >>) will remain unchanged. This is a key difference between
using C<forward> and issuing a redirect.

You can pass new arguments to a C<forward> by adding them
in an anonymous array. In this case C<< $c->req->args >>
will be changed for the duration of the C<forward> only; upon
return, the original value of C<< $c->req->args >> will
be reset.

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $c->forward('check_message',[qw/test1/]);
        # now $c->req->args is back to what it was before
    }

    sub check_message : Action {
        my ( $self, $c, $first_argument ) = @_;
        my $also_first_argument = $c->req->args->[0]; # now = 'test1'
        # do something...
    }

As you can see from these examples, you can just use the method name as
long as you are referring to methods in the same controller. If you want
to forward to a method in another controller, or the main application,
you will have to refer to the method by absolute path.

  $c->forward('/my/controller/action');
  $c->forward('/default'); # calls default in main application

You can also forward to classes and methods.

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->forward(qw/MyApp::View:Hello say_hello/);
    }

    sub bye : Global {
        my ( $self, $c ) = @_;
        $c->forward('MyApp::Model::Hello'); # no method: will try 'process'
    }

    package MyApp::View::Hello;

    sub say_hello {
        my ( $self, $c ) = @_;
        $c->res->body('Hello World!');
    }

    sub process {
        my ( $self, $c ) = @_;
        $c->res->body('Goodbye World!');
    }

This mechanism is used by L<Catalyst::Action::RenderView> to forward
to the C<process> method in a view class.

It should be noted that whilst forward is useful, it is not the only way
of calling other code in Catalyst. Forward just gives you stats in the debug
screen, wraps the code you're calling in an exception handler and localises
C<< $c->request->args >>.

If you don't want or need these features then it's perfectly acceptable
(and faster) to do something like this:

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $self->check_message( $c, 'test1' );
    }

    sub check_message {
        my ( $self, $c, $first_argument ) = @_;
        # do something...
    }

Note that C<forward> returns to the calling action and continues
processing after the action finishes. If you want all further processing
in the calling action to stop, use C<detach> instead, which will execute
the C<detach>ed action and not return to the calling sub. In both cases,
Catalyst will automatically try to call process() if you omit the
method.

=head3 Testing

Catalyst has a built-in http server for testing or local
deployment. (Later, you can easily use a more powerful server, for
example Apache/mod_perl or FastCGI, in a production environment.)

Start your application on the command line...

    script/myapp_server.pl

...then visit http://localhost:3000/ in a browser to view the output.

You can also do it all from the command line:

    script/myapp_test.pl http://localhost/

Catalyst has a number of tools for actual regression testing of
applications. The helper scripts will automatically generate basic tests
that can be extended as you develop your project. To write your own
comprehensive test scripts, L<Test::WWW::Mechanize::Catalyst> is an
invaluable tool.

For more testing ideas, see L<Catalyst::Manual::Tutorial::08_Testing>.

Have fun!

=head1 SEE ALSO

=over 4

=item * L<Catalyst::Manual::About>

=item * L<Catalyst::Manual::Tutorial>

=item * L<Catalyst>

=back

=head1 SUPPORT

IRC:

    Join #catalyst on irc.perl.org.
    Join #catalyst-dev on irc.perl.org to help with development.

Mailing lists:

    http://lists.scsys.co.uk/mailman/listinfo/catalyst
    http://lists.scsys.co.uk/mailman/listinfo/catalyst-dev

Wiki:

    http://dev.catalystframework.org/wiki

FAQ:

    http://dev.catalystframework.org/wiki/faq

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
